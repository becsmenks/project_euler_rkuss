# Project Euler
# projecteuler.net
# Becca Kuss

source('~/git/project_euler_rkuss/euler_problems_r/euler_functions.R')

# Problem 1 - Multiples of 3 and 5 ----------------------------------------

# If we list all the natural numbers below 10 that are multiples of 3 or 5, we
# get 3, 5, 6 and 9. The sum of these multiples is 23.
#
# Find the sum of all the multiples of 3 or 5 below 1000.

data.frame(number = 1:999) %>%
  mutate(is_mult_3 = number %% 3 == 0,
         is_mult_5 = number %% 5 == 0) %>%
  filter(is_mult_3 | is_mult_5) %>%
  summarise(sum = sum(number)) %>%
  pull(sum)

# 233168 - CORRECT!

# Problem 2 - Even Fibonacci numbers --------------------------------------

# Each new term in the Fibonacci sequence is generated by adding the previous
# two terms. By starting with 1 and 2, the first 10 terms will be:
#  
#   1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
#
# By considering the terms in the Fibonacci sequence whose values do not exceed
# four million, find the sum of the even-valued terms.

fib_seq <- generate_fib_seq(4000000)

data.frame(fn = fib_seq) %>%
  mutate(is_even = fn %% 2 == 0) %>%
  filter(is_even) %>%
  summarise(sum = sum(fn)) %>%
  pull(sum)

# 4613732 - CORRECT!

# Problem 3 - Largest prime factor ----------------------------------------

# The prime factors of 13195 are 5, 7, 13 and 29.
#
# What is the largest prime factor of the number 600851475143 ?

primes_up_to_n <- sieve_of_eratosthenes(30000)

# Check if our big number is divisible by each prime number
quotients <- 600851475143 / primes_up_to_n

integer_quotients <- 600851475143 %/% primes_up_to_n

max(primes_up_to_n[quotients == integer_quotients])

# 6857 - CORRECT!

# Problem 4 - Largest palindrome product ----------------------------------

# A palindromic number reads the same both ways. The largest palindrome made
# from the product of two 2-digit numbers is 9009 = 91 × 99.
#
# Find the largest palindrome made from the product of two 3-digit numbers.

three_digit_nums <- 100:999

three_digit_combos <- data.frame(num1 = three_digit_nums) %>%
  merge(data.frame(num2 = three_digit_nums)) %>%
  mutate(product = num1 * num2,
         product_char = as.character(product),
         n_char = str_length(product_char),
         first_digits = str_sub(product_char,
                                start = 1,
                                end = floor(n_char / 2)),
         first_digits_n_char = str_length(first_digits),
         digit_n = str_sub(product_char,
                           start = n_char,
                           end = n_char),
         digit_n_minus1 = str_sub(product_char,
                                  start = n_char - 1,
                                  end = n_char - 1),
         digit_n_minus2 = str_sub(product_char,
                                  start = n_char - 2,
                                  end = n_char - 2),
         last_digits_rev = if_else(first_digits_n_char == 2,
                                   paste0(digit_n, digit_n_minus1),
                                   paste0(digit_n, digit_n_minus1, digit_n_minus2)),
         is_palindrome = first_digits == last_digits_rev)

three_digit_combos %>%
  filter(is_palindrome) %>%
  summarise(max = max(product)) %>%
  pull(max)

# 906609 - CORRECT!

# Problem 5 - Smallest multiple -------------------------------------------

# 2520 is the smallest number that can be divided by each of the numbers from 1
# to 10 without any remainder.
#
# What is the smallest positive number that is evenly divisible by all of the
# numbers from 1 to 20?

divis_by_up_to <- 20

# Make a data frame that stores the maximum number of times each prime shows up
# in the prime factorization of each number up to our number
prime_times <- c()
for (k in 2:divis_by_up_to) {
  
  # Start with prime factorization of every number up to 10 or 20
  prime_fact_k <- c()
  n <- k
  
  # 1) While n is divisible by 2, print 2 and divide n by 2.
  while (n %% 2 == 0) {
    prime_fact_k <- c(prime_fact_k, 2)
    n <- n / 2
  }
  
  # 2) After step 1, n must be odd. Now start a loop from i = 3 to square root 
  # of n. While i divides n, print i and divide n by i. After i fails to divide 
  # n, increment i by 2 and continue.
  if (n > 2) {
    for (i in seq(from = 3, to = max(sqrt(n),3), by = 2)) {
      while (n %% 3 == 0) {
        prime_fact_k <- c(prime_fact_k, i)
        n <- n / i
      }
    }
  }
  
  # 3) If n is a prime number and is greater than 2, then n will not become 1 by 
  # above two steps. So print n if it is greater than 2.
  if (n > 2) prime_fact_k <- c(prime_fact_k, n)
  
  prime_fact_k_freq <- data.frame(table(prime_fact_k)) %>% 
    mutate(k = k) %>% 
    select(k, p = prime_fact_k, freq = Freq)
  
  prime_times <- bind_rows(prime_times,
                           prime_fact_k_freq)
  
}

# Find the maximum number of times each prime appears and multiply them all 
# together that many times
prime_times %>% 
  group_by(p) %>% 
  summarise(freq = max(freq)) %>% 
  ungroup() %>% 
  mutate(p2 = as.numeric(as.character(p)),
         p3 = p2^freq) %>% 
  pull(p3) %>% 
  prod()

# 232792560 - CORRECT!

# Problem 6 - Sum square difference ---------------------------------------

# The sum of the squares of the first ten natural numbers is,
#
# The square of the sum of the first ten natural numbers is,
#
# Hence the difference between the sum of the squares of the first ten natural
# numbers and the square of the sum is .
#
# Find the difference between the sum of the squares of the first one hundred
# natural numbers and the square of the sum.


data.frame(number = 1:100) %>%
  mutate(square = number^2) %>%
  summarise(sum_of_squares = sum(square),
            square_of_sum = sum(number)^2) %>%
  mutate(difference = square_of_sum - sum_of_squares) %>%
  pull(difference)

# 25164150 - CORRECT!

# Problem 7 - 10001st prime -----------------------------------------------

# By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see t
# hat the 6th prime is 13.
#
# What is the 10 001st prime number?


# Get all prime numbers up to 125k
first_primes <- sieve_of_eratosthenes(125000)

first_primes[10001]

# 104743 - CORRECT!

# Problem 8 - Largest product in a series ---------------------------------

# The four adjacent digits in the 1000-digit number that have the greatest
# product are 9 × 9 × 8 × 9 = 5832.
#
#
# Find the thirteen adjacent digits in the 1000-digit number that have the
# greatest product. What is the value of this product?


thsnd_digit_num <- paste0('73167176531330624919225119674426574742355349194934',
                          '96983520312774506326239578318016984801869478851843',
                          '85861560789112949495459501737958331952853208805511',
                          '12540698747158523863050715693290963295227443043557',
                          '66896648950445244523161731856403098711121722383113',
                          '62229893423380308135336276614282806444486645238749',
                          '30358907296290491560440772390713810515859307960866',
                          '70172427121883998797908792274921901699720888093776',
                          '65727333001053367881220235421809751254540594752243',
                          '52584907711670556013604839586446706324415722155397',
                          '53697817977846174064955149290862569321978468622482',
                          '83972241375657056057490261407972968652414535100474',
                          '82166370484403199890008895243450658541227588666881',
                          '16427171479924442928230863465674813919123162824586',
                          '17866458359124566529476545682848912883142607690042',
                          '24219022671055626321111109370544217506941658960408',
                          '07198403850962455444362981230987879927244284909188',
                          '84580156166097919133875499200524063689912560717606',
                          '05886116467109405077541002256983155200055935729725',
                          '71636269561882670428252483600823257530420752963450')

digits <- data.frame(digit = str_split(thsnd_digit_num, "")[[1]]) %>%
  mutate(digit = as.numeric(as.character(digit)))

adj_digits <- 13
for (col in 1:(adj_digits - 1)) {
  digits <- digits %>%
    mutate(UQ(paste0("lag", col)) := lag(digit, col))
}

digits %>%
  mutate(product = digit * lag1 * lag2 * lag3 * lag4 * lag5 * lag6 * lag7 *
           lag8 * lag9 * lag10 * lag11 * lag12) %>%
  filter(!is.na(product)) %>%
  pull(product) %>%
  max()

# 23514624000 - CORRECT!

# Problem 9 - Special Pythagorean triplet ---------------------------------

# A Pythagorean triplet is a set of three natural numbers, a < b < c, for which,
#
# a2 + b2 = c2
# For example, 32 + 42 = 9 + 16 = 25 = 52.
#
# There exists exactly one Pythagorean triplet for which a + b + c = 1000.
# Find the product abc.

# Algebra:
# c = 1000 - (a + b)
# a^2 + b^2 = (1000 - (a + b))^2
# a^2 + b^2 = 1000^2 - 1000*(a+b) - 1000*(a+b) + (a+b)^2
# a^2 + b^2 = 1000^2 - 1000*(a+b) - 1000*(a+b) + a^2 + 2ab + b^2
# 0 = 1000^2 - 1000*(a+b) - 1000*(a+b) + 2ab
# 0 = 1000^2 - 2000a - 2000b + 2ab

# Brute force:
try_up_to <- 1000
data.frame(a = 1:try_up_to) %>%
  merge(data.frame(b = 1:try_up_to)) %>%
  filter(a < b) %>%
  mutate(a2 = a^2,
         b2 = b^2,
         c2 = a2 + b2,
         c = sqrt(c2),
         sum = a + b + c,
         product = a * b * c) %>%
  filter(sum == 1000) %>%
  pull(product)

# 31875000 - CORRECT!

# Problem 10 - Summation of primes ----------------------------------------

# The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.
#
# Find the sum of all the primes below two million.

find_below <- 2000000

# Need a list of all primes up to sqrt(n)
pr <- sieve_of_eratosthenes(ceiling(sqrt(find_below)))

# Start with a list of everything to test less than our number
whats_left <- 2:(find_below - 1)

# Remove all multiples of primes 
for (p in pr) {
  
  multiples_of_prime <- seq(from = 2 * p, to = find_below, by = p)
  whats_left <- whats_left[!(whats_left %in% multiples_of_prime)]
  
}

sum(whats_left)

# 142913828922 - CORRECT!

# Problem 11 - Largest product in a grid ----------------------------------

# In the 20×20 grid below, four numbers along a diagonal line have been marked
# in red.
#
# The product of these numbers is 26 × 63 × 78 × 14 = 1788696.
#
# What is the greatest product of four adjacent numbers in the same direction
# (up, down, left, right, or diagonally) in the 20×20 grid?

grid_raw <- data.frame(matrix(c(08, 02, 22, 97, 38, 15, 00, 40, 00, 75,
                                04, 05, 07, 78, 52, 12, 50, 77, 91, 08,
                                49, 49, 99, 40, 17, 81, 18, 57, 60, 87,
                                17, 40, 98, 43, 69, 48, 04, 56, 62, 00,
                                81, 49, 31, 73, 55, 79, 14, 29, 93, 71,
                                40, 67, 53, 88, 30, 03, 49, 13, 36, 65,
                                52, 70, 95, 23, 04, 60, 11, 42, 69, 24,
                                68, 56, 01, 32, 56, 71, 37, 02, 36, 91,
                                22, 31, 16, 71, 51, 67, 63, 89, 41, 92,
                                36, 54, 22, 40, 40, 28, 66, 33, 13, 80,
                                24, 47, 32, 60, 99, 03, 45, 02, 44, 75,
                                33, 53, 78, 36, 84, 20, 35, 17, 12, 50,
                                32, 98, 81, 28, 64, 23, 67, 10, 26, 38,
                                40, 67, 59, 54, 70, 66, 18, 38, 64, 70,
                                67, 26, 20, 68, 02, 62, 12, 20, 95, 63,
                                94, 39, 63, 08, 40, 91, 66, 49, 94, 21,
                                24, 55, 58, 05, 66, 73, 99, 26, 97, 17,
                                78, 78, 96, 83, 14, 88, 34, 89, 63, 72,
                                21, 36, 23, 09, 75, 00, 76, 44, 20, 45,
                                35, 14, 00, 61, 33, 97, 34, 31, 33, 95,
                                78, 17, 53, 28, 22, 75, 31, 67, 15, 94,
                                03, 80, 04, 62, 16, 14, 09, 53, 56, 92,
                                16, 39, 05, 42, 96, 35, 31, 47, 55, 58,
                                88, 24, 00, 17, 54, 24, 36, 29, 85, 57,
                                86, 56, 00, 48, 35, 71, 89, 07, 05, 44,
                                44, 37, 44, 60, 21, 58, 51, 54, 17, 58,
                                19, 80, 81, 68, 05, 94, 47, 69, 28, 73,
                                92, 13, 86, 52, 17, 77, 04, 89, 55, 40,
                                04, 52, 08, 83, 97, 35, 99, 16, 07, 97,
                                57, 32, 16, 26, 26, 79, 33, 27, 98, 66,
                                88, 36, 68, 87, 57, 62, 20, 72, 03, 46,
                                33, 67, 46, 55, 12, 32, 63, 93, 53, 69,
                                04, 42, 16, 73, 38, 25, 39, 11, 24, 94,
                                72, 18, 08, 46, 29, 32, 40, 62, 76, 36,
                                20, 69, 36, 41, 72, 30, 23, 88, 34, 62,
                                99, 69, 82, 67, 59, 85, 74, 04, 36, 16,
                                20, 73, 35, 29, 78, 31, 90, 01, 74, 31,
                                49, 71, 48, 86, 81, 16, 23, 57, 05, 54,
                                01, 70, 54, 71, 83, 51, 54, 69, 16, 92,
                                33, 48, 61, 43, 52, 01, 89, 19, 67, 48),
                              nrow = 20,
                              byrow = TRUE))

grid <- grid_raw %>%
  mutate(row = 1:20) %>%
  gather("col", "value", starts_with("X")) %>%
  mutate(col = as.numeric(str_remove(col, "X")),
         diag_down = row - col,
         diag_up = row + col)

grid %>%
  # Get vertical groups of four
  group_by(col) %>%
  arrange(row) %>%
  mutate(above1 = lag(value, 1),
         above2 = lag(value, 2),
         above3 = lag(value, 3)) %>%
  ungroup() %>%
  # Get horizontal groups of four
  group_by(row) %>%
  arrange(col) %>%
  mutate(left1 = lag(value, 1),
         left2 = lag(value, 2),
         left3 = lag(value, 3)) %>%
  ungroup() %>%
  # Get diagonal-down groups of four
  group_by(diag_down) %>%
  arrange(row) %>%
  mutate(aboveleft1 = lag(value, 1),
         aboveleft2 = lag(value, 2),
         aboveleft3 = lag(value, 3)) %>%
  ungroup() %>%
  # Get diagonal-up groups of four
  group_by(diag_up) %>%
  arrange(col) %>%
  mutate(belowleft1 = lag(value, 1),
         belowleft2 = lag(value, 2),
         belowleft3 = lag(value, 3)) %>%
  ungroup() %>%
  # Calculate products
  mutate(vertical_product = value * above1 * above2 * above3,
         horizontal_product = value * left1 * left2 * left3,
         diag_down_product = value * aboveleft1 * aboveleft2 * aboveleft3,
         diag_up_product = value * belowleft1 * belowleft2 * belowleft3) %>%
  select(row, col, vertical_product, horizontal_product, diag_down_product,
         diag_up_product) %>%
  gather("group", "product", vertical_product:diag_up_product) %>%
  filter(!is.na(product)) %>%
  pull(product) %>%
  max()

# 70600674 - CORRECT!

# Problem 12 - Highly divisible triangular number -------------------------

# The sequence of triangle numbers is generated by adding the natural numbers. 
# So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first 
# ten terms would be:
#   
#   1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
# 
# Let us list the factors of the first seven triangle numbers:
#   
# 1: 1
# 3: 1,3
# 6: 1,2,3,6
# 10: 1,2,5,10
# 15: 1,3,5,15
# 21: 1,3,7,21
# 28: 1,2,4,7,14,28
# 
# We can see that 28 is the first triangle number to have over five divisors.
# 
# What is the value of the first triangle number to have over five hundred 
# divisors?

# Start with a sequence of triangle numbers and calculate number of divisors
tri_seq <- data.frame(n = 1:1000) %>% 
  mutate(tn = cumsum(n),
         n_div = get_n_div(tn))
tri_seq2 <- data.frame(n = 10000:11110) %>% 
  mutate(tn = cumsum(n),
         n_div = get_n_div(tn))

tri_seq3 <- data.frame(n = 1:10000) %>% 
  mutate(tn = cumsum(n))

tri_seq4 <- tri_seq3 %>% 
  filter(n > 9950) %>% 
  mutate(n_div = get_n_div(tn))

# Find the first one to have certain number of divisors
# Works, bu too slow to scale
over_n_divisors <- 500
tri_seq2 %>% 
  filter(n_div > over_n_divisors) %>% 
  summarise(m = min(tn)) %>% 
  pull(m)


# Try the looping method
i <- 13000
n_div <- 0
while ((n_div < 500) & (i < 15000)) {
  
  # Get the next triangular number and its list of possible divisors
  tn <- sum(1:(i+1))
  poss_div <- 1:ceiling((tn+1)/2)
  
  # Check number of divisors
  n_div_tn <- sum(tn %% poss_div == 0)
  print(n_div_tn)
  
  # Update max number of divisors
  n_div <- n_div_tn
  i <- i + 1
  
}
  
  
# Problem 13 - Large sum --------------------------------------------------

# Work out the first ten digits of the sum of the following one-hundred 50-digit 
# numbers.

options(digits = 12)

fifty_digit_nums <- c(37107287533902102798797998220837590246510135740250,
                      46376937677490009712648124896970078050417018260538,
                      74324986199524741059474233309513058123726617309629,
                      91942213363574161572522430563301811072406154908250,
                      23067588207539346171171980310421047513778063246676,
                      89261670696623633820136378418383684178734361726757,
                      28112879812849979408065481931592621691275889832738,
                      44274228917432520321923589422876796487670272189318,
                      47451445736001306439091167216856844588711603153276,
                      70386486105843025439939619828917593665686757934951,
                      62176457141856560629502157223196586755079324193331,
                      64906352462741904929101432445813822663347944758178,
                      92575867718337217661963751590579239728245598838407,
                      58203565325359399008402633568948830189458628227828,
                      80181199384826282014278194139940567587151170094390,
                      35398664372827112653829987240784473053190104293586,
                      86515506006295864861532075273371959191420517255829,
                      71693888707715466499115593487603532921714970056938,
                      54370070576826684624621495650076471787294438377604,
                      53282654108756828443191190634694037855217779295145,
                      36123272525000296071075082563815656710885258350721,
                      45876576172410976447339110607218265236877223636045,
                      17423706905851860660448207621209813287860733969412,
                      81142660418086830619328460811191061556940512689692,
                      51934325451728388641918047049293215058642563049483,
                      62467221648435076201727918039944693004732956340691,
                      15732444386908125794514089057706229429197107928209,
                      55037687525678773091862540744969844508330393682126,
                      18336384825330154686196124348767681297534375946515,
                      80386287592878490201521685554828717201219257766954,
                      78182833757993103614740356856449095527097864797581,
                      16726320100436897842553539920931837441497806860984,
                      48403098129077791799088218795327364475675590848030,
                      87086987551392711854517078544161852424320693150332,
                      59959406895756536782107074926966537676326235447210,
                      69793950679652694742597709739166693763042633987085,
                      41052684708299085211399427365734116182760315001271,
                      65378607361501080857009149939512557028198746004375,
                      35829035317434717326932123578154982629742552737307,
                      94953759765105305946966067683156574377167401875275,
                      88902802571733229619176668713819931811048770190271,
                      25267680276078003013678680992525463401061632866526,
                      36270218540497705585629946580636237993140746255962,
                      24074486908231174977792365466257246923322810917141,
                      91430288197103288597806669760892938638285025333403,
                      34413065578016127815921815005561868836468420090470,
                      23053081172816430487623791969842487255036638784583,
                      11487696932154902810424020138335124462181441773470,
                      63783299490636259666498587618221225225512486764533,
                      67720186971698544312419572409913959008952310058822,
                      95548255300263520781532296796249481641953868218774,
                      76085327132285723110424803456124867697064507995236,
                      37774242535411291684276865538926205024910326572967,
                      23701913275725675285653248258265463092207058596522,
                      29798860272258331913126375147341994889534765745501,
                      18495701454879288984856827726077713721403798879715,
                      38298203783031473527721580348144513491373226651381,
                      34829543829199918180278916522431027392251122869539,
                      40957953066405232632538044100059654939159879593635,
                      29746152185502371307642255121183693803580388584903,
                      41698116222072977186158236678424689157993532961922,
                      62467957194401269043877107275048102390895523597457,
                      23189706772547915061505504953922979530901129967519,
                      86188088225875314529584099251203829009407770775672,
                      11306739708304724483816533873502340845647058077308,
                      82959174767140363198008187129011875491310547126581,
                      97623331044818386269515456334926366572897563400500,
                      42846280183517070527831839425882145521227251250327,
                      55121603546981200581762165212827652751691296897789,
                      32238195734329339946437501907836945765883352399886,
                      75506164965184775180738168837861091527357929701337,
                      62177842752192623401942399639168044983993173312731,
                      32924185707147349566916674687634660915035914677504,
                      99518671430235219628894890102423325116913619626622,
                      73267460800591547471830798392868535206946944540724,
                      76841822524674417161514036427982273348055556214818,
                      97142617910342598647204516893989422179826088076852,
                      87783646182799346313767754307809363333018982642090,
                      10848802521674670883215120185883543223812876952786,
                      71329612474782464538636993009049310363619763878039,
                      62184073572399794223406235393808339651327408011116,
                      66627891981488087797941876876144230030984490851411,
                      60661826293682836764744779239180335110989069790714,
                      85786944089552990653640447425576083659976645795096,
                      66024396409905389607120198219976047599490197230297,
                      64913982680032973156037120041377903785566085089252,
                      16730939319872750275468906903707539413042652315011,
                      94809377245048795150954100921645863754710598436791,
                      78639167021187492431995700641917969777599028300699,
                      15368713711936614952811305876380278410754449733078,
                      40789923115535562561142322423255033685442488917353,
                      44889911501440648020369068063960672322193204149535,
                      41503128880339536053299340368006977710650566631954,
                      81234880673210146739058568557934581403627822703280,
                      82616570773948327592232845941706525094512325230608,
                      22918802058777319719839450180888072429661980811197,
                      77158542502016545090413245809786882778948721859617,
                      72107838435069186155435662884062257473692284509516,
                      20849603980134001723930671666823555245252804609722,
                      53503534226472524250874054075591789781264330331690)

floor(sum(fifty_digit_nums) / 1e42)

# 5537376230 - CORRECT!

# Problem 14 - Longest Collatz sequence -----------------------------------

# The following iterative sequence is defined for the set of positive integers:
#   
# n → n/2 (n is even)
# n → 3n + 1 (n is odd)
# 
# Using the rule above and starting with 13, we generate the following sequence:
#   
#   13 → 40 → 20 → 10 → 5 → 16 → 8 → 4 → 2 → 1
# It can be seen that this sequence (starting at 13 and finishing at 1) contains 
# 10 terms. Although it has not been proved yet (Collatz Problem), it is thought 
# that all starting numbers finish at 1.
# 
# Which starting number, under one million, produces the longest chain?
#   
# NOTE: Once the chain starts the terms are allowed to go above one million.

collatz_lengths <- data.frame()
all_collatz_terms <- c()
for (starting_num in 999999:1) {
  
  if (starting_num %in% all_collatz_terms) next
  
  # message(starting_num)
  
  # Initialize everything
  i <- starting_num
  collatz_seq <- starting_num
  reached_one <- FALSE
  
  while (!reached_one) {
    
    # Increment based on rules
    if (i %% 2 == 0) {
      i <- i / 2
    } else {
      i <- (3 * i) + 1
    }
    
    # Append to sequence
    collatz_seq <- c(collatz_seq, i)
    
    # Check if we reached 1 yet
    reached_one <- i == 1
    
  }
  
  # Save resulting length
  collatz_lengths <- bind_rows(collatz_lengths,
                               data.frame(start_n = starting_num,
                                          len = length(collatz_seq)))
  
  # Save all numbers appearing in sequence, we'll skip these later on because
  # they can't be the longest sequences
  all_collatz_terms <- c(all_collatz_terms, collatz_seq)
  
}

collatz_lengths %>% 
  filter(len == max(len)) %>% 
  pull(start_n)


# Problem 15 - Lattice paths ----------------------------------------------

# Starting in the top left corner of a 2×2 grid, and only being able to move to 
# the right and down, there are exactly 6 routes to the bottom right corner.
# 
# How many such routes are there through a 20×20 grid?

grid_dim <- 20

# How many moves are required to reach the bottom corner?
required_moves <- grid_dim * 2

# Half of the moves have to be down and half right, so how many different ways
# can you pick half down moves and half right moves?
factorial(required_moves) / (factorial(grid_dim) * factorial(grid_dim))

# 137846528820 - CORRECT!

# Problem 17 - Number letter counts ---------------------------------------

# If the numbers 1 to 5 are written out in words: one, two, three, four, five, 
# then there are 3 + 3 + 5 + 4 + 4 = 19 letters used in total.
# 
# If all the numbers from 1 to 1000 (one thousand) inclusive were written out in 
# words, how many letters would be used?
#   
# NOTE: Do not count spaces or hyphens. For example, 342 (three hundred and 
# forty-two) contains 23 letters and 115 (one hundred and fifteen) contains 20 
# letters. The use of "and" when writing out numbers is in compliance with 
# British usage.

ones_pl_words <- data.frame(ones_place = 1:9,
                            ones_place_word = c("one", "two", "three", "four",
                                                "five", "six", "seven", "eight",
                                                "nine"))

tens_pl_words <- data.frame(tens_place = 1:9,
                            tens_place_word = c("teen", "twenty", "thirty", 
                                                "forty", "fifty", "sixty", 
                                                "seventy", "eighty", "ninety"))

huns_pl_words <- data.frame(huns_place = 1:9,
                            huns_place_word = c("one", "two", "three", "four",
                                                "five", "six", "seven", "eight",
                                                "nine"))

nums_and_words <- data.frame(number = 1:1000) %>% 
  mutate(n_digits = str_length(as.character(number)),
         ones_place = as.numeric(str_sub(as.character(number), 
                                         n_digits, n_digits)),
         tens_place = as.numeric(str_sub(as.character(number), 
                                         n_digits - 1, n_digits - 1)),
         huns_place = as.numeric(str_sub(as.character(number), 
                                         n_digits - 2, n_digits - 2))) %>% 
  left_join(ones_pl_words, by = "ones_place") %>% 
  left_join(tens_pl_words, by = "tens_place") %>% 
  left_join(huns_pl_words, by = "huns_place") %>% 
  replace_na(list(ones_place_word = "",
                  tens_place_word = "")) %>% 
  mutate(ones_place_word = case_when(tens_place == 1 & ones_place == 1 ~ "", 
                                     tens_place == 1 & ones_place == 2 ~ "", 
                                     tens_place == 1 & ones_place == 3 ~ "thir", 
                                     tens_place == 1 & ones_place == 5 ~ "fif", 
                                     tens_place == 1 & ones_place == 8 ~ "eigh", 
                                     TRUE ~ ones_place_word),
         tens_place_word = case_when(tens_place == 1 & ones_place == 0 ~ "ten", 
                                     tens_place == 1 & ones_place == 1 ~ "eleven", 
                                     tens_place == 1 & ones_place == 2 ~ "twelve", 
                                     TRUE ~ tens_place_word),
         word = case_when(n_digits == 1 ~ ones_place_word,
                          n_digits == 2 & 
                            tens_place == 1 ~ paste(ones_place_word, 
                                                    tens_place_word),
                          n_digits == 2 ~ paste(tens_place_word, 
                                                ones_place_word),
                          n_digits == 3 & 
                            tens_place == 0 & 
                            ones_place == 0 ~ paste(huns_place_word, "hundred"),
                          n_digits == 3 & 
                            tens_place == 1 ~ paste(huns_place_word,
                                                    "hundred and",
                                                    ones_place_word, 
                                                    tens_place_word),
                          n_digits == 3 ~ paste(huns_place_word,
                                                "hundred and",
                                                tens_place_word, 
                                                ones_place_word),
                          TRUE ~ "one thousand"),
         word_no_sp = str_remove_all(word, " "),
         len = str_length(word_no_sp))

nums_and_words %>% 
  summarise(len = sum(len)) %>% 
  pull(len)

# 21124 - CORRECT!


# Problem 18 - Maximum path sum I -----------------------------------------

# By starting at the top of the triangle below and moving to adjacent numbers on 
# the row below, the maximum total from top to bottom is 23.
# 
# 3
# 7 4
# 2 4 6
# 8 5 9 3
# 
# That is, 3 + 7 + 4 + 9 = 23.
# 
# Find the maximum total from top to bottom of the triangle below:
#   
# NOTE: As there are only 16384 routes, it is possible to solve this problem by 
# trying every route. However, Problem 67, is the same challenge with a triangle 
# containing one-hundred rows; it cannot be solved by brute force, and requires 
# a clever method! ;o)

tri <- matrix(c(3, 0, 0, 0,
                7, 4, 0, 0,
                2, 4, 6, 0,
                8, 5, 9, 3),
              nrow = 4,
              byrow = TRUE)

tri <- matrix(c(75, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00,
                95, 64, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00,
                17, 47, 82, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00,
                18, 35, 87, 10, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00,
                20, 04, 82, 47, 65, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00,
                19, 01, 23, 75, 03, 34, 00, 00, 00, 00, 00, 00, 00, 00, 00,
                88, 02, 77, 73, 07, 63, 67, 00, 00, 00, 00, 00, 00, 00, 00,
                99, 65, 04, 28, 06, 16, 70, 92, 00, 00, 00, 00, 00, 00, 00,
                41, 41, 26, 56, 83, 40, 80, 70, 33, 00, 00, 00, 00, 00, 00,
                41, 48, 72, 33, 47, 32, 37, 16, 94, 29, 00, 00, 00, 00, 00,
                53, 71, 44, 65, 25, 43, 91, 52, 97, 51, 14, 00, 00, 00, 00, 
                70, 11, 33, 28, 77, 73, 17, 78, 39, 68, 17, 57, 00, 00, 00, 
                91, 71, 52, 38, 17, 14, 91, 43, 58, 50, 27, 29, 48, 00, 00, 
                63, 66, 04, 68, 89, 53, 67, 30, 73, 16, 69, 87, 40, 31, 00,
                04, 62, 98, 27, 23, 09, 70, 98, 73, 93, 38, 53, 60, 04, 23),
              nrow = 15,
              byrow = T)

# Set up data frame with decision variables and their values
tri_df <- data.frame(tri) %>% 
  tibble::rownames_to_column("row") %>% 
  gather(col, value, starts_with("X")) %>% 
  mutate(col = str_remove(col, "X"),
         d_var = paste0(row, "-", col),
         row = as.numeric(row),
         col = as.numeric(col)) %>% 
  arrange(d_var) 

# Create objective function coefficients
obj_coeff <- tri_df %>% 
  pull(value)

# Constraint 1 - sum of all rows is exactly 1
constr1_df <- tri_df %>% 
  mutate(constr_id = as.character(row),
         constr_val = 1,
         dir = "=",
         rhs = 1) %>% 
  select(d_var, dir, rhs, constr_id, constr_val) %>% 
  spread(d_var, constr_val) %>% 
  replace(is.na(.), 0)

# Constraint 2 - can only pick adjacent cells
constr2_df <- tri_df %>% 
  filter(row > 1) %>% 
  rename(constr_id = d_var) %>% 
  mutate(cell_constr = paste0(row, "-", col),
         cell_above_right = paste0(row - 1, "-", col),
         cell_above_left = paste0(row - 1, "-", col - 1)) %>% 
  gather(cell, d_var, starts_with("cell")) %>% 
  filter(d_var %in% tri_df$d_var) %>% 
  mutate(constr_val = if_else(cell == "cell_constr", 1, -1),
         dir = "<=",
         rhs = 0) %>% 
  select(d_var, dir, rhs, constr_id, constr_val) %>% 
  spread(d_var, constr_val) %>% 
  replace(is.na(.), 0)

# Constraint 3 - don't pick the upper diagonal
constr3_df <- tri_df %>% 
  mutate(constr_id = d_var,
         constr_val = if_else(col > row, 1, 0),
         dir = "=",
         rhs = 0) %>% 
  spread(d_var, constr_val) %>% 
  filter(col > row) %>% 
  select(-c(row, col, value)) %>% 
  replace(is.na(.), 0)

# Combine constraint data frames
constr_df <- bind_rows(constr1_df,
                       constr2_df,
                       constr3_df)

# Create constraint matrix, direction, and rhs
constr_mat <- constr_df %>% 
  select(all_of(tri_df$d_var)) %>% 
  as.matrix()

constr_dir <- constr_df %>% 
  pull(dir)

constr_rhs <- constr_df %>% 
  pull(rhs)

# Solve the linear program
soln <- lp(direction = "max",
           objective.in = obj_coeff,
           const.mat = constr_mat,
           const.dir = constr_dir,
           const.rhs = constr_rhs,
           all.bin = T)

soln$objval

# 1074 - CORRECT!

# Problem 19 - Counting Sundays -------------------------------------------

# You are given the following information, but you may prefer to do some 
# research for yourself.
# 
# 1 Jan 1900 was a Monday.
# Thirty days has September,
# April, June and November.
# All the rest have thirty-one,
# Saving February alone,
# Which has twenty-eight, rain or shine.
# And on leap years, twenty-nine.
# A leap year occurs on any year evenly divisible by 4, but not on a century 
# unless it is divisible by 400.
# How many Sundays fell on the first of the month during the twentieth century 
# (1 Jan 1901 to 31 Dec 2000)?

dates <- data.frame(date = seq(from = as.Date("1901-01-01"),
                               to = as.Date("2000-12-31"),
                               by = 1)) %>% 
  mutate(day = day(date),
         dow = weekdays(date))

dates %>% 
  filter(day == 1,
         dow == "Sunday") %>% 
  nrow()

# 171 - CORRECT!

# Problem 21 - Amicable numbers -------------------------------------------

# Let d(n) be defined as the sum of proper divisors of n (numbers less than n 
# which divide evenly into n).
# If d(a) = b and d(b) = a, where a ≠ b, then a and b are an amicable pair and 
# each of a and b are called amicable numbers.
# 
# For example, the proper divisors of 220 are 1, 2, 4, 5, 10, 11, 20, 22, 44, 
# 55 and 110; therefore d(220) = 284. The proper divisors of 284 are 1, 2, 4, 71 
# and 142; so d(284) = 220.
# 
# Evaluate the sum of all the amicable numbers under 10000.

p <- sieve_of_eratosthenes(sqrt(10000) + 1)

amic_num <- c()
for (n in 2:9999) {
  
  # Skip primes, they have no divisors
  if (is_prime(n, p)) next
  # Skip any numbers already amicable
  if (n %in% amic_num) next
  
  message(n)
  
  dn <- sum((1:(n-1))[n %% (1:(n-1)) == 0])
  ddn <- sum((1:(dn-1))[dn %% (1:(dn-1)) == 0])
  
  if (n == ddn & n != dn) amic_num <- c(amic_num, n, dn)
  
}

sum(amic_num)

# 31626 - CORRECT!

# Problem 22 - Names scores -----------------------------------------------

# Using names.txt (right click and 'Save Link/Target As...'), a 46K text file 
# containing over five-thousand first names, begin by sorting it into 
# alphabetical order. Then working out the alphabetical value for each name, 
# multiply this value by its alphabetical position in the list to obtain a name 
# score.
# 
# For example, when the list is sorted into alphabetical order, COLIN, which is 
# worth 3 + 15 + 12 + 9 + 14 = 53, is the 938th name in the list. So, COLIN 
# would obtain a score of 938 × 53 = 49714.
# 
# What is the total of all the name scores in the file?

# Read in names data
names <- read.csv("~/git/project_euler_rkuss/euler_data/p022_names.txt",
                  header = F, na.strings = "") %>% 
  gather(key, name, starts_with("V")) %>% 
  filter(!is.na(name)) %>% 
  select(name)

# Create lookup of letter scores
letter_scores <- data.frame(letter = str_to_upper(letters),
                            letter_score = 1:length(letters))

# Find out how many columns are needed to split up the longest name
split_into <- names %>% 
  mutate(n_char = str_length(name)) %>% 
  pull(n_char) %>% 
  max()

# Calculate name scores
names_scores <- names %>% 
  arrange(name) %>% 
  mutate(alpha_rank = row_number(),
         name_splt = str_split(name, "")) %>% 
  separate(name_splt, 
           into = as.character(1:split_into), 
           sep = ",") %>% 
  gather(position, letter, `1`:as.character(split_into)) %>% 
  mutate(letter = str_remove_all(letter, 'c\\(\\"'),
         letter = str_remove_all(letter, '\\"\\)'),
         letter = str_remove_all(letter, '\\"'),
         letter = str_remove_all(letter, ' ')) %>% 
  filter(!is.na(letter)) %>% 
  left_join(letter_scores, by = "letter") %>% 
  group_by(name, alpha_rank) %>% 
  summarise(letter_total = sum(letter_score)) %>% 
  ungroup() %>% 
  mutate(score = alpha_rank * letter_total)

sum(names_scores$score)

# 871198282 - CORRECT!

# Problem 23 - Non-abundant sums ------------------------------------------


# A perfect number is a number for which the sum of its proper divisors is 
# exactly equal to the number. For example, the sum of the proper divisors of 28 
# would be 1 + 2 + 4 + 7 + 14 = 28, which means that 28 is a perfect number.
# 
# A number n is called deficient if the sum of its proper divisors is less than 
# n and it is called abundant if this sum exceeds n.
# 
# As 12 is the smallest abundant number, 1 + 2 + 3 + 4 + 6 = 16, the smallest 
# number that can be written as the sum of two abundant numbers is 24. By 
# mathematical analysis, it can be shown that all integers greater than 28123 
# can be written as the sum of two abundant numbers. However, this upper limit 
# cannot be reduced any further by analysis even though it is known that the 
# greatest number that cannot be expressed as the sum of two abundant numbers is 
# less than this limit.
# 
# Find the sum of all the positive integers which cannot be written as the sum 
# of two abundant numbers.

num_types <- data.frame()
for (i in 1:28123) {
  # Find all divisors of i
  divsrs_to_test <- 1:(i/2)
  divsrs <- divsrs_to_test[i %% divsrs_to_test == 0]
  
  num_types <- bind_rows(num_types,
                         data.frame(n = i,
                                    sum_divsrs = sum(divsrs)))
}

# Classify numbers as deficient, abundant, or perfect
num_types <- num_types %>% 
  mutate(type = case_when(sum_divsrs < n ~ 'deficient',
                          sum_divsrs > n ~ 'abundant',
                          sum_divsrs == n ~ 'perfect'))

# Get a list of all abundant numbers
abundant_numbers <- num_types %>% 
  filter(type == "abundant") %>% 
  pull(n)

num_tests <- data.frame()
for (j in 1:28123) {
  # Test whether n can be written as the sum of two abundant numbers
  abnt_nums_lt <- abundant_numbers[abundant_numbers < j]
  remainders <- j - abnt_nums_lt
  
  # Save record
  num_tests <- bind_rows(num_tests,
                         data.frame(n = j,
                                    can_be = any(remainders %in% abnt_nums_lt)))
}

num_tests %>% 
  filter(!can_be) %>% 
  summarise(sum = sum(n)) %>% 
  pull(sum)

# 4179871 - CORRECT!

# Problem 24 - Lexicographic permutations ---------------------------------

# A permutation is an ordered arrangement of objects. For example, 3124 is one 
# possible permutation of the digits 1, 2, 3 and 4. If all of the permutations 
# are listed numerically or alphabetically, we call it lexicographic order. The 
# lexicographic permutations of 0, 1 and 2 are:
#   
#   012   021   102   120   201   210
# 
# What is the millionth lexicographic permutation of the digits 0, 1, 2, 3, 4, 
# 5, 6, 7, 8 and 9?

digits_to_permute <- 0:9
position_to_find <- 1000000

# Start by calculating the number of permutations based on number of digits
n_permutations <- factorial(length(digits_to_permute))

# Next get how long each "chunk" will be (that is, a group starting with the 
# same character)
chunk_length <- n_permutations / length(digits_to_permute)

# Next get how many "chunks" there will be (this could also be length(digits))
n_chunks <- n_permutations / chunk_length

answer <- c()
for (i in 1:(length(digits_to_permute) - 1)) {
  
  # Find the chunk that will contain the permutation in the position you are
  # looking for
  chunk_to_find <- ceiling(position_to_find / chunk_length)
  
  # Now we know the starting digit of that chunk
  answer <- c(answer, digits_to_permute[chunk_to_find])
  
  # For the next round, remove the digit you already found
  digits_to_permute <- digits_to_permute[-chunk_to_find]
  
  # For the next round, update the position to find
  position_to_find <- position_to_find - ((chunk_to_find - 1) * chunk_length)
    
  # For the next round, update the chunk length
  chunk_length <- factorial(length(digits_to_permute)) / length(digits_to_permute)
  
}

# Append the last remaining digit to permute
answer <- c(answer, digits_to_permute)

# Paste all the digits together for the final answer
paste0(as.character(answer), collapse = "")

# 2783915460 - CORRECT!


# Problem 25 - 1000-digit Fibonacci number --------------------------------

# The Fibonacci sequence is defined by the recurrence relation:
#   
#   Fn = Fn−1 + Fn−2, where F1 = 1 and F2 = 1.
# Hence the first 12 terms will be:
#   
# F1 = 1
# F2 = 1
# F3 = 2
# F4 = 3
# F5 = 5
# F6 = 8
# F7 = 13
# F8 = 21
# F9 = 34
# F10 = 55
# F11 = 89
# F12 = 144
# The 12th term, F12, is the first term to contain three digits.
# 
# What is the index of the first term in the Fibonacci sequence to contain 1000 
# digits?


fib_digits <- data.frame(fn = generate_fib_seq(1e1000)) %>% 
  mutate(n_digits = floor(log10(fn) + 1))

fib_digits_counts <- fib_digits %>% 
  group_by(n_digits) %>% 
  summarise(n_fn = n())

# Seems like the pattern is something like 45554555545555 repeating, starting
# with n_digits = 311
pattern_to_proj <- c(4, 5,5,5,4,5,5,5,5,4,5,5,5,5)

starting_n_digits <- 311
n_patterns <- ceiling((1000 - starting_n_digits) / length(pattern_to_proj))
ending_n_digits <- starting_n_digits + (n_patterns * length(pattern_to_proj)) - 1
n_digits_proj <- starting_n_digits:ending_n_digits

# Project out this pattern until we reach Fibonacci numbers with at least 1000
# digits
fib_digits_counts_proj <- data.frame(n_digits = n_digits_proj,
                                     n_fn = rep(pattern_to_proj, 
                                                times = n_patterns)) %>% 
  bind_rows(data.frame(n_digits = 310, n_fn = 5))

# Combine the projected counts to get fn counts through 1000
fib_digits_counts_combined <- fib_digits_counts %>% 
  mutate(n_fn = if_else(n_digits == 309, as.integer(5), n_fn)) %>% 
  bind_rows(fib_digits_counts_proj)

# Find the number of Fibonacci numbers with less than 1000 digits and add 1
fib_digits_counts_combined %>% 
  filter(n_digits < 1000) %>% 
  summarise(n_fn = sum(n_fn)) %>% 
  pull(n_fn) + 1
  
# 4782 - CORRECT!


# Problem 26 - Reciprocal cycles ------------------------------------------

# A unit fraction contains 1 in the numerator. The decimal representation of the 
# unit fractions with denominators 2 to 10 are given:
#   
# 1/2	= 	0.5
# 1/3	= 	0.(3)
# 1/4	= 	0.25
# 1/5	= 	0.2
# 1/6	= 	0.1(6)
# 1/7	= 	0.(142857)
# 1/8	= 	0.125
# 1/9	= 	0.(1)
# 1/10	= 	0.1
# Where 0.1(6) means 0.166666..., and has a 1-digit recurring cycle. It can be 
# seen that 1/7 has a 6-digit recurring cycle.
# 
# Find the value of d < 1000 for which 1/d contains the longest recurring cycle 
# in its decimal fraction part.

recurr_sequences <- data.frame()
for (d in 1:999) {
  
  # Initialize things
  result <- c() 
  prev_remainders <- c()
  rem <- 1 %% d
  
  # Keep finding remainder until either remainder becomes 0 or repeats
  while ((rem != 0) & !(rem %in% prev_remainders)) {
    
    # Store this remainder
    prev_remainders <- c(prev_remainders, rem)
    
    # Multiply remainder with 10
    rem <- rem * 10
    
    # Append remainder / d to result
    result_part <- floor(rem / d)
    result <- c(result, result_part)
    
    # Update remainder
    rem <- rem %% d
    
  }
  
  # Figure out the recurring part
  if (rem == 0) {
    recurr_seq <- ""
    recurr_seq_len <- 0
  } else {
    recurr_seq <- result[which(prev_remainders == rem):length(result)]
    recurr_seq_len <- length(recurr_seq)
  }
  
  # Append result to data frame
  recurr_sequences <- data.frame(d = d,
                                 recurr_seq = paste0(recurr_seq,
                                                     collapse = ""),
                                 recurr_seq_len = recurr_seq_len) %>% 
    bind_rows(recurr_sequences)
    
}

# Find d with the longest recurring sequence
recurr_sequences %>% 
  filter(recurr_seq_len == max(recurr_seq_len)) %>% 
  pull(d)

# 983 - CORRECT!


# Problem 27 - Quadratic primes -------------------------------------------

# Euler discovered the remarkable quadratic formula:
#   n^2 + n + 41
#   
# It turns out that the formula will produce 40 primes for the consecutive 
# integer values 0<=n<=39. However, when n = 40, 40^2 + 40 + 41 = 40(40+1) + 41 
# is divisible by 41, and certainly when n = 41, 41^2 + 41 + 41 is clearly 
# divisible by 41.
# 
# The incredible formula n^2 - 79n + 1601 was discovered, which produces 80 
# primes for the consecutive values 0<=n<=79. The product of the coefficients, 
# −79 and 1601, is −126479.
# 
# Considering quadratics of the form:
#   
#   n^2 + an + b, where |a|<1000 and |b|<=1000
# 
# where |n| is the modulus/absolute value of n
# e.g. |11|=11 and |-4|=4
# 
# Find the product of the coefficients, a and b, for the quadratic expression 
# that produces the maximum number of primes for consecutive values of n, 
# starting with n=0.

primes_lt_1000 <- sieve_of_eratosthenes(1000)

a <- -999:999
b <- primes_lt_1000

ab_combos <- data.frame(a) %>% 
  merge(data.frame(b))


candidates <- ab_combos
n <- 0
while (nrow(candidates) > 1) {
  
  # Increment n
  n <- n + 1
  print(n)
  
  candidates <- candidates %>% 
    mutate(q = (n^2) + (a * n) + b) %>% 
    filter(q >= 0, # can't have negative primes
           (q %% 2 != 0 | q == 2), # can't have even numbers except for two
           q %% 3 != 0,
           q %% 5 != 0,
           q %% 7 != 0,
           q %% 11 != 0,
           q %% 13 != 0,
           q %% 17 != 0) %>% 
    mutate(q_pr = is_prime(q, primes_lt_1000)) %>% 
    filter(q_pr) %>% 
    select(a, b)
}

candidates$a * candidates$b

# -59231 - CORRECT!

# Problem 28 - Number spiral diagonals ------------------------------------


# Starting with the number 1 and moving to the right in a clockwise direction a 
# 5 by 5 spiral is formed as follows:
#   
# 21 22 23 24 25
# 20  7  8  9 10
# 19  6  1  2 11
# 18  5  4  3 12
# 17 16 15 14 13
# 
# It can be verified that the sum of the numbers on the diagonals is 101.
# 
# What is the sum of the numbers on the diagonals in a 1001 by 1001 spiral 
# formed in the same way?

n <- 1001

spiral <- data.frame(i = 1:floor(n / 2)) %>% 
  mutate(upper_right = ((2 * i) + 1)^2,
         lower_right = upper_right - (6 * i),
         upper_left = upper_right - (2 * i),
         lower_left = (2 * i)^2 + 1)

spiral %>% 
  select(-i) %>% 
  sum() + 1
  
# 669171001 - CORRECT!
  

# Problem 29 - Distinct powers --------------------------------------------

# Consider all integer combinations of a^b for 2 ≤ a ≤ 5 and 2 ≤ b ≤ 5:
#   
#   2^2=4, 2^3=8, 2^4=16, 2^5=32
#   3^2=9, 3^3=27, 3^4=81, 3^5=243
#   4^2=16, 4^3=64, 4^4=256, 4^5=1024
#   5^2=25, 5^3=125, 5^4=625, 5^5=3125
# 
# If they are then placed in numerical order, with any repeats removed, we get 
# the following sequence of 15 distinct terms:
#   
#   4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125
# 
# How many distinct terms are in the sequence generated by a^b for 2 ≤ a ≤ 100 
# and 2 ≤ b ≤ 100?

max_val <- 100

a <- 2:max_val
b <- 2:max_val

a_b_combos <- data.frame(a) %>% 
  merge(data.frame(b)) %>% 
  mutate(term = a ^ b) %>% 
  arrange(term)

distinct(a_b_combos, term) %>% 
  nrow()

# 9183 - CORRECT!


# Problem 30 - Digit fifth powers -----------------------------------------

# Surprisingly there are only three numbers that can be written as the sum of 
# fourth powers of their digits:
#   
# 1634 = 1^4 + 6^4 + 3^4 + 4^4
# 8208 = 8^4 + 2^4 + 0^4 + 8^4
# 9474 = 9^4 + 4^4 + 7^4 + 4^4
# 
# As 1 = 1^4 is not a sum it is not included.
# 
# The sum of these numbers is 1634 + 8208 + 9474 = 19316.
# 
# Find the sum of all the numbers that can be written as the sum of fifth powers 
# of their digits.

power <- 5

# This is just a guess of how many numbers to test. It could probably be 
# determined based on 'power', but I got lucky and this one works
scale_to_test <- 6

nums <- data.frame(number = 2:((10^scale_to_test) - 1)) %>% 
  mutate(number_char = as.character(number)) %>% 
  separate(number_char, 
           into = as.character(1:(scale_to_test + 1)),
           sep = "",
           remove = T) %>% 
  gather(digit_i, digit, -number) %>% 
  mutate(digit = as.numeric(digit),
         digit_power = digit ^ power) %>% 
  filter(!is.na(digit))

nums %>% 
  group_by(number) %>% 
  summarise(sum_digit_power = sum(digit_power)) %>% 
  filter(number == sum_digit_power) %>% 
  ungroup() %>% 
  pull(number) %>% 
  sum()

# 443839 - CORRECT!

# Problem 31 - Coin sums --------------------------------------------------

# In the United Kingdom the currency is made up of pound (£) and pence (p). 
# There are eight coins in general circulation:
#   
#   1p, 2p, 5p, 10p, 20p, 50p, £1 (100p), and £2 (200p).
# 
# It is possible to make £2 in the following way:
#   
#   1×£1 + 1×50p + 2×20p + 1×5p + 1×2p + 3×1p
# How many different ways can £2 be made using any number of coins?
  
coins <- tribble(
  ~coin, ~value,
  "1p",  1,
  "2p",  2,
  "5p",  5,
  "10p", 10,
  "20p", 20,
  "50p", 50,
  "E1",  100,
  "E2",  200
)
  
n_ways_1p <- 1

n_ways_2p <- 2

n_ways_3p <- 2

n_ways_5p <- 2 + n_ways_3p

n_ways_10p <- 1 + (n_ways_5p^2)

n_ways_20p <- 1 + (n_ways_10p^2)

n_ways_40p <- n_ways_20p^2

n_ways_50p <- 1 + (n_ways_40p * n_ways_10p)

n_ways_1E <- 1 + (n_ways_50p^2)

n_ways_2E <- 1 + (n_ways_1E^2)

# Problem 33 - Digit cancelling fractions ---------------------------------

# The fraction 49/98 is a curious fraction, as an inexperienced mathematician in 
# attempting to simplify it may incorrectly believe that 49/98 = 4/8, which is 
# correct, is obtained by cancelling the 9s.
# 
# We shall consider fractions like, 30/50 = 3/5, to be trivial examples.
# 
# There are exactly four non-trivial examples of this type of fraction, less 
# than one in value, and containing two digits in the numerator and denominator.
# 
# If the product of these four fractions is given in its lowest common terms, 
# find the value of the denominator.


digit_cancelling_fracs <- data.frame(num = 10:99) %>% 
  merge(data.frame(den = 10:99)) %>% 
  # Separate digits
  mutate(num_digit2 = num %% 10,
         den_digit2 = den %% 10,
         num_digit1 = (num - num_digit2) / 10,
         den_digit1 = (den - den_digit2) / 10) %>% 
  # Fraction must be less than one, so filter for num < den
  filter(num < den,
         # These are the only candidates for digit-cancelling
         num_digit2 == den_digit2 |
           num_digit1 == den_digit1 |
           num_digit1 == den_digit2 |
           num_digit2 == den_digit1,
         # These are trivial
         !(num_digit2 == 0 & den_digit2 == 0)) %>% 
  # Check if reduced fraction equals original fraction
  mutate(orig_frac = num / den,
         redc_frac = case_when(
           num_digit2 == den_digit2 ~ num_digit1 / den_digit1,
           num_digit1 == den_digit1 ~ num_digit2 / den_digit2,
           num_digit1 == den_digit2 ~ num_digit2 / den_digit1,
           num_digit2 == den_digit1 ~ num_digit1 / den_digit2
         )) %>% 
  filter(orig_frac == redc_frac)

frac_product <- digit_cancelling_fracs %>% 
  pull(orig_frac) %>% 
  prod()

1 / frac_product

# 100 - CORRECT!

# Problem 34 - Digit factorials -------------------------------------------

# 145 is a curious number, as 1! + 4! + 5! = 1 + 24 + 120 = 145.
# 
# Find the sum of all numbers which are equal to the sum of the factorial of 
# their digits.
# 
# Note: As 1! = 1 and 2! = 2 are not sums they are not included.

scale_to_test <- 5

digit_facts <- data.frame(number = 3:((10^scale_to_test) - 1)) %>% 
  mutate(number_char = as.character(number)) %>% 
  separate(number_char, 
           into = as.character(1:(scale_to_test + 1)),
           sep = "",
           remove = T) %>% 
  gather(digit_i, digit, -number) %>% 
  mutate(digit = as.numeric(digit),
         digit_fact = factorial(digit)) %>% 
  filter(!is.na(digit))

digit_facts %>% 
  group_by(number) %>% 
  summarise(sum_digit_facts = sum(digit_fact)) %>% 
  ungroup() %>% 
  filter(number == sum_digit_facts) %>% 
  pull(number) %>% 
  sum()

# 40730 - CORRECT!


# Problem 35 - Circular primes --------------------------------------------

# The number, 197, is called a circular prime because all rotations of the 
# digits: 197, 971, and 719, are themselves prime.
# 
# There are thirteen such primes below 100: 2, 3, 5, 7, 11, 13, 17, 31, 37, 71, 
# 73, 79, and 97.
# 
# How many circular primes are there below one million?

x <- 1000000

primes_lt_sqrt_x <- sieve_of_eratosthenes(sqrt(x))

primes_lt_x <- (1:x)[is_prime(1:x, primes_lt_sqrt_x)]



# Problem 36 - Double-base palindromes ------------------------------------

# The decimal number, 585 = 1001001001 (binary), is palindromic in both bases.
# 
# Find the sum of all numbers, less than one million, which are palindromic in 
# base 10 and base 2.
# 
# (Please note that the palindromic number, in either base, may not include 
# leading zeros.)

db_pals <- c()
for (i in 1:999999) {
  
  # Check if number is palindromic in base 10
  i_ten <- str_split(as.character(i), pattern = "")[[1]]
  
  if (all(i_ten == rev(i_ten))) {
    # Check if number is palindromic in base 2
    i_raw <- intToBits(i)
    i_bin <- str_split(paste0(as.numeric(i_raw[1:max(which(i_raw > 0))]), 
                              collapse = ""),
                       pattern = "")[[1]]
    
    if (all(i_bin == rev(i_bin))) {
      db_pals <- c(db_pals, i)
    }
  }
}

sum(db_pals)


# Problem 37 - Truncatable primes -----------------------------------------

# The number 3797 has an interesting property. Being prime itself, it is 
# possible to continuously remove digits from left to right, and remain prime at 
# each stage: 3797, 797, 97, and 7. Similarly we can work from right to left: 
# 3797, 379, 37, and 3.
# 
# Find the sum of the only eleven primes that are both truncatable from left to 
# right and right to left.
# 
# NOTE: 2, 3, 5, and 7 are not considered to be truncatable primes.

primes_up_to_n <- sieve_of_eratosthenes(50000)

trunc_primes <- data.frame(p = primes_up_to_n) %>% 
  filter(p > 7) %>% 
  mutate(scale = case_when(p < 100 ~ 10,
                           p < 1000 ~ 100,
                           p < 10000 ~ 1000,
                           p < 100000 ~ 10000),
         # Truncate by dropping digits from the left
         drop_l1 = p - (floor(p / scale) * scale),
         drop_l2 = drop_l1 - if_else(scale > 10,
                                     (floor(drop_l1 / (scale / 10)) * (scale / 10)),
                                     NA_real_),
         drop_l3 = drop_l2 - if_else(scale > 100,
                                     (floor(drop_l2 / (scale / 100)) * (scale / 100)),
                                     NA_real_),
         drop_l4 = drop_l2 - if_else(scale > 1000,
                                     (floor(drop_l2 / (scale / 1000)) * (scale / 1000)),
                                     NA_real_),
         # Truncate by dropping digits from the left
         drop_r1 = floor(p / 10),
         drop_r2 = if_else(scale > 10, floor(p / 100), NA_real_),
         drop_r3 = if_else(scale > 100, floor(p / 1000), NA_real_),
         drop_r4 = if_else(scale > 1000, floor(p / 10000), NA_real_))

trunc_primes %>% 
  gather(key, value, starts_with("drop")) %>% 
  filter(!is.na(value)) %>% 
  mutate(value_is_prime = is_prime(value, primes_up_to_n)) %>% 
  group_by(p) %>% 
  summarise(all_still_p = all(value_is_prime)) %>% 
  filter(all_still_p) %>% 
  pull(p) %>% 
  sum()


# Problem 39 - Integer right triangles ------------------------------------

# If p is the perimeter of a right angle triangle with integral length sides, 
# {a,b,c}, there are exactly three solutions for p = 120.
# 
# {20,48,52}, {24,45,51}, {30,40,50}
# 
# For which value of p ≤ 1000, is the number of solutions maximised?

# Test each value of a with two equations, two unknowns
# a + b + c = p   --> b = p - a - c
# a^2 + b^2 = c^2 --> a^2 + (p - a - c)^2 = c^2
#                 --> a^2 + (p-a)^2 - 2c*(p-a) + c^2 = c^2
#                 --> a^2 + (p-a)^2 - 2c*(p-a) = 0
#                 --> ((a^2 + (p-a)^2) / (p-a)) / 2 = c

num_int_tris <- c()
for (p in 3:1000) {
  
  # Find all the integer triangles for p
  int_triangles <- c()
  for (a in 1:((p / 2) - 1)) {
    
    # Calculate b and c based on algebra
    c <- ((a^2 + (p-a)^2) / (p-a)) / 2 
    b <- p - a - c
    
    # Check if all are integers
    all_ints <- b == round(b) & c == round(c)
    
    # Add the triangle if it's integer-sided
    if (all_ints) {
      int_triangles <- int_triangles %>% 
        bind_rows(data.frame(matrix(sort(c(a,b,c)), nrow = 1))) %>% 
        distinct()
    }
  }
  
  # Count the number of integer-sided triangles
  n <- if_else(is.null(nrow(int_triangles)), 
               as.integer(0), 
               nrow(int_triangles))
  
  num_int_tris <- num_int_tris %>% 
    bind_rows(data.frame(p, n))
  
}

num_int_tris %>% 
  filter(n == max(n)) %>% 
  pull(p)

# 840 - CORRECT!


# Problem 40 - Champernowne's constant ------------------------------------

# An irrational decimal fraction is created by concatenating the positive 
# integers:
#   
#   0.123456789101112131415161718192021...
# 
# It can be seen that the 12th digit of the fractional part is 1.
# 
# If dn represents the nth digit of the fractional part, find the value of the 
# following expression.
# 
# d1 × d10 × d100 × d1000 × d10000 × d100000 × d1000000


# Count how many digits are made up of one-digit numbers, two-digit, ...
contributions <- data.frame(n_digits = 1:7) %>% 
  mutate(n_numbers = if_else(n_digits == 1, 9, 10^n_digits),
         n_digits_contributed = n_digits * n_numbers,
         n_digits_total = cumsum(n_digits_contributed))

# Use this string to check the algorithm
str_check <- paste0(1:1000000, collapse = "")

# Already know the first two
d <- c(1, 1)
d_check <- c("1", "1")
for (n in c(100, 1000, 10000, 100000, 1000000)) {
  
  dn <- contributions %>% 
    mutate(is_bucket = n_digits_total >= n & lag(n_digits_total) < n,
           digits_in = n - lag(n_digits_total),
           numbers_in = floor(digits_in / n_digits),
           winning_number = numbers_in + (10^(n_digits - 1) - 1),
           prior_digits = numbers_in * n_digits,
           winning_digit = digits_in - prior_digits + 1,
           answer = str_sub(as.character(winning_number), 
                            winning_digit, winning_digit)) %>% 
    filter(is_bucket) %>% 
    pull(answer) %>% 
    as.numeric()
  
  d <- c(d, dn)
  
  d_check <- c(d_check, str_sub(str_check, n, n))
  
}

# Turns out the algorithm is wrong, but it's super easy to brute force this one
# using strings
prod(as.numeric(d_check))

# 210 - CORRECT!

# Problem 42 - Coded triangle numbers -------------------------------------

# The nth term of the sequence of triangle numbers is given by, tn = ½n(n+1); so 
# the first ten triangle numbers are:
#   
#   1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
# 
# By converting each letter in a word to a number corresponding to its 
# alphabetical position and adding these values we form a word value. For 
# example, the word value for SKY is 19 + 11 + 25 = 55 = t10. If the word value 
# is a triangle number then we shall call the word a triangle word.
# 
# Using words.txt (right click and 'Save Link/Target As...'), a 16K text file 
# containing nearly two-thousand common English words, how many are triangle 
# words?

words <- read.csv('~/git/project_euler_rkuss/euler_data/p042_words.txt',
                  header = F) %>% 
  gather(key, word, starts_with("V")) %>% 
  select(word)

# Create lookup of letter values
letter_values <- data.frame(letter = str_to_upper(letters),
                            letter_value = 1:length(letters))

# Find out how many columns are needed to split up the longest name
split_into <- words %>% 
  mutate(n_char = str_length(word)) %>% 
  pull(n_char) %>% 
  max()

# Calculate word values
words_values <- words %>% 
  mutate(word_splt = str_split(word, "")) %>% 
  separate(word_splt, into = as.character(1:split_into), sep = ",") %>% 
  gather(position, letter, `1`:as.character(split_into)) %>% 
  mutate(letter = str_remove_all(letter, 'c\\(\\"'),
         letter = str_remove_all(letter, '\\"\\)'),
         letter = str_remove_all(letter, '\\"'),
         letter = str_remove_all(letter, ' ')) %>% 
  filter(!is.na(letter)) %>% 
  left_join(letter_values, by = "letter") %>% 
  group_by(word) %>% 
  summarise(word_value = sum(letter_value)) %>% 
  ungroup()

# Find all the triangle numbers
tri_nums <- data.frame(n = 1:500) %>%
  mutate(tn = (1 / 2) * n * (n + 1))

# Check if words are triangle words
words_values %>% 
  filter(word_value %in% tri_nums$tn) %>% 
  nrow()

# 162 - CORRECT!


# Problem 43 - Sub-string divisibility ------------------------------------

# The number, 1406357289, is a 0 to 9 pandigital number because it is made up of 
# each of the digits 0 to 9 in some order, but it also has a rather interesting 
# sub-string divisibility property.
# 
# Let d1 be the 1st digit, d2 be the 2nd digit, and so on. In this way, we note 
# the following:
#   
# d2d3d4=406 is divisible by 2
# d3d4d5=063 is divisible by 3
# d4d5d6=635 is divisible by 5
# d5d6d7=357 is divisible by 7
# d6d7d8=572 is divisible by 11
# d7d8d9=728 is divisible by 13
# d8d9d10=289 is divisible by 17
# Find the sum of all 0 to 9 pandigital numbers with this property.

p_divisors <- c(2,3,5,7,11,13,17)

# First come up with all the allowable three-digit numbers that have three
# distinct digits
distinct_three_digits <- data.frame(num = 11:999) %>% 
  mutate(num_char = if_else(num < 100, paste0("0", as.character(num)),
                            as.character(num))) %>% 
  separate(num_char, into = c("blank", "a", "b", "c"), sep = "", remove = F) %>% 
  filter(!(a == b | b == c | c == a)) %>% 
  select(num, num_char)

# Find all three-digit numbers (with three distinct digits) divisible by each 
# prime divisor
distinct_three_digits_mults <- data.frame(p = p_divisors) %>% 
  merge(distinct_three_digits) %>% 
  filter(num %% p == 0) %>% 
  mutate(first_digits = str_sub(num_char, 1, 2),
         last_digits = str_sub(num_char, 2, 3))

# Initialize a data frame to hold the growing string of numbers
growing_string <- distinct_three_digits_mults %>% 
  filter(p == 2) %>% 
  select(growing_string = num_char, join_digits = last_digits)

for (k in 2:length(p_divisors)) {
  
  # Pull out the three-digits numbers divisible by pk
  next_multiples <- distinct_three_digits_mults %>% 
    filter(p == p_divisors[k]) %>% 
    select(num_char, join_digits = first_digits)
  
  growing_string <- growing_string %>% 
    # Join on the first/last two digits
    left_join(next_multiples, by = "join_digits") %>% 
    mutate(new_growing_string = paste0(growing_string, 
                                       str_sub(num_char, 3, 3))) %>% 
    filter(!is.na(num_char)) %>% 
    # Check for indistinct digits
    separate(new_growing_string, 
             into = c("blank", as.character(1:(k + 2))), 
             sep = "", remove = F) %>% 
    gather(position, digit, as.character(1:(k + 2))) %>% 
    group_by(new_growing_string) %>% 
    summarise(distinct_digits = n_distinct(digit)) %>% 
    filter(distinct_digits == (k + 2)) %>% 
    # Reformat back to original columns
    select(growing_string = new_growing_string) %>% 
    mutate(join_digits = str_sub(growing_string, k + 1, k + 2))
  
}

final_strings <- growing_string %>% 
  select(growing_string) %>% 
  separate(growing_string, into = c("blank", as.character(1:9)), 
           sep = "", remove = F) %>% 
  gather(position, digit, as.character(1:(k + 2))) %>% 
  group_by(growing_string) %>% 
  mutate(first_digit = case_when(all(digit != "1") ~ "1",
                                 all(digit != "2") ~ "2",
                                 all(digit != "3") ~ "3",
                                 all(digit != "4") ~ "4",
                                 all(digit != "5") ~ "5",
                                 all(digit != "6") ~ "6",
                                 all(digit != "7") ~ "7",
                                 all(digit != "8") ~ "8",
                                 all(digit != "9") ~ "9")) %>% 
  mutate(final_string = paste0(first_digit, growing_string)) %>% 
  distinct(final_string) %>% 
  pull(final_string)

sum(as.numeric(final_strings))

# 16695334890 - CORRECT!


# Problem 54 - Poker hands ------------------------------------------------

# In the card game poker, a hand consists of five cards and are ranked, from 
# lowest to highest, in the following way:
#   
#   High Card: Highest value card.
#   One Pair: Two cards of the same value.
#   Two Pairs: Two different pairs.
#   Three of a Kind: Three cards of the same value.
#   Straight: All cards are consecutive values.
#   Flush: All cards of the same suit.
#   Full House: Three of a kind and a pair.
#   Four of a Kind: Four cards of the same value.
#   Straight Flush: All cards are consecutive values of same suit.
#   Royal Flush: Ten, Jack, Queen, King, Ace, in same suit.
# 
# The cards are valued in the order:
#   2, 3, 4, 5, 6, 7, 8, 9, 10, Jack, Queen, King, Ace.
# 
# If two players have the same ranked hands then the rank made up of the highest 
# value wins; for example, a pair of eights beats a pair of fives (see example 1 
# below). But if two ranks tie, for example, both players have a pair of queens, 
# then highest cards in each hand are compared (see example 4 below); if the 
# highest cards tie then the next highest cards are compared, and so on.
# 
# Consider the following five hands dealt to two players:
#   
# Hand   Player 1	 	        Player 2	 	       Winner
# 1	 	   5H 5C 6S 7S KD     2C 3S 8S 8D TD     Player 2
#        Pair of Fives      Pair of Eights
#   
# 2	 	   5D 8C 9S JS AC     2C 5C 7D 8S QH     Player 1
#        Highest card Ace   Highest card Queen
#   
# 3	 	   2D 9C AS AH AC     3D 6D 7D TD QD     Player 2
#        Three Aces         Flush with Diamonds
#   
# 4	 	   4D 6S 9H QH QC     3D 6D 7H QD QS     Player 1
#        Pair of Queens     Pair of Queens
#        Highest card Nine  Highest card Seven
# 
# 5	 	   2H 2D 4C 4D 4S     3C 3D 3S 9S 9D     Player 1
#        Full House         Full House
#        With Three Fours   With Three Threes
# 
# The file, poker.txt, contains one-thousand random hands dealt to two players. 
# Each line of the file contains ten cards (separated by a single space): the 
# first five are Player 1's cards and the last five are Player 2's cards. You 
# can assume that all hands are valid (no invalid characters or repeated cards), 
# each player's hand is in no specific order, and in each hand there is a clear 
# winner.
# 
# How many hands does Player 1 win?

hand_type_values <- tribble(
  ~type,         ~type_value,
  "royal flush",      10,
  "straight flush",   9,
  "four of a kind",   8,
  "full house",       7,
  "flush",            6,
  "straight",         5,
  "three of a kind",  4,
  "two pairs",        3,
  "one pair",         2,
  "high card",        1
)

poker <- read.csv('~/git/project_euler_rkuss/euler_data/p054_poker.txt',
                  header = F) %>% 
  separate(V1, into = c("p1a", "p1b", "p1c", "p1d", "p1e",
                        "p2a", "p2b", "p2c", "p2d", "p2e"), sep = " ")

poker_hands <- poker %>% 
  mutate(hand = 1:nrow(poker)) %>% 
  gather(player, card, starts_with("p")) %>% 
  mutate(player = if_else(str_detect(player, "p1"), "Player 1", "Player 2"),
         card_value = str_sub(card, 1, 1),
         card_value = case_when(card_value == "A" ~ 14,
                                card_value == "K" ~ 13,
                                card_value == "Q" ~ 12,
                                card_value == "J" ~ 11,
                                card_value == "T" ~ 10,
                                TRUE ~ as.numeric(card_value)),
         card_suit = str_sub(card, 2, 2))

hand_types <- poker_hands %>% 
  # Add some helper columns
  group_by(hand, player, card_value) %>% 
  mutate(n = n()) %>% 
  ungroup() %>% 
  # Check for each type of hand
  group_by(hand, player) %>% 
  summarise(type = case_when(
    n_distinct(card_suit) == 1 & min(card_value) == 10 ~ "royal flush",
    n_distinct(card_suit) == 1 & min(card_value) == max(card_value) - 4 ~ 
      "straight flush",
    n_distinct(card_value) == 2 & max(n) == 4 ~ "four of a kind",
    n_distinct(card_value) == 2 & max(n) == 3 ~ "full house",
    n_distinct(card_suit) == 1 ~ "flush",
    min(card_value) == max(card_value) - 4 & max(n) == 1 ~ "straight",
    max(n) == 3 ~ "three of a kind",
    max(n) == 2 & n_distinct(card_value) == 3 ~ "two pairs",
    max(n) == 2 ~ "one pair",
    TRUE ~ "high card"),
    tie_breaker = case_when(type %in% c("four of a kind", "three of a kind",
                                        "two pairs", "one pair") ~ 
                              max(card_value[n == max(n)]),
                            TRUE ~ max(card_value))) %>% 
  ungroup()


hand_types %>% 
  left_join(hand_type_values, by = "type") %>% 
  group_by(hand) %>% 
  mutate(verdict = case_when(type_value > min(type_value) ~ "winner",
                             type_value < max(type_value) ~ "loser",
                             # handle ties
                             tie_breaker > min(tie_breaker) ~ "winner",
                             tie_breaker < max(tie_breaker) ~ "loser",
                             # these are still ties
                             TRUE ~ "tie")) %>% 
  filter(player == "Player 1",
         verdict == "winner") %>% 
  nrow()

# 376 - CORRECT!

# Problem 58 - Spiral primes ----------------------------------------------

# Starting with 1 and spiralling anticlockwise in the following way, a square 
# spiral with side length 7 is formed.
# 
# 37 36 35 34 33 32 31
# 38 17 16 15 14 13 30
# 39 18  5  4  3 12 29
# 40 19  6  1  2 11 28
# 41 20  7  8  9 10 27
# 42 21 22 23 24 25 26
# 43 44 45 46 47 48 49
# 
# It is interesting to note that the odd squares lie along the bottom right 
# diagonal, but what is more interesting is that 8 out of the 13 numbers lying 
# along both diagonals are prime; that is, a ratio of 8/13 ≈ 62%.
# 
# If one complete new layer is wrapped around the spiral above, a square spiral 
# with side length 9 will be formed. If this process is continued, what is the 
# side length of the square spiral for which the ratio of primes along both 
# diagonals first falls below 10%?

# Start by finding a lot of primes
p <- sieve_of_eratosthenes(50000)

# Set the threshold we're waiting to fall under
prime_ratio_thresh <- 0.1

# Initialize everything
r <- 1
side_length <- 1
diag_nums <- 1
primes_on_diag <- c()

# Add spiraling layers until meeting threshold
while (r >= prime_ratio_thresh & side_length < 100000) {
  
  # Increment side length
  side_length <- side_length + 2
  
  # Find the numbers along the diagonal
  ul <- side_length ^ 2 - ((side_length - 1) * 2) # upper left 
  ur <- side_length ^ 2 - ((side_length - 1) * 3) # upper right
  ll <- side_length ^ 2 - ((side_length - 1) * 1) # lower left 
  lr <- side_length ^ 2 # lower right 
  
  # Check for primality
  if (is_prime(ur, p)) primes_on_diag <- c(primes_on_diag, ur)
  if (is_prime(ul, p)) primes_on_diag <- c(primes_on_diag, ul)
  if (is_prime(ll, p)) primes_on_diag <- c(primes_on_diag, ll)
  
  # Save numbers along the diagonal
  diag_nums <- c(diag_nums, ur, ul, ll, lr)
  
  r <- length(primes_on_diag) / length(diag_nums)
  
}

side_length

# 26241 - CORRECT!


# Problem 66 - Diophantine equation ---------------------------------------

# Consider quadratic Diophantine equations of the form:
#   
#   x2 – Dy2 = 1
# 
# For example, when D=13, the minimal solution in x is 6492 – 13×1802 = 1.
# 
# It can be assumed that there are no solutions in positive integers when D is 
# square.
# 
# By finding minimal solutions in x for D = {2, 3, 5, 6, 7}, we obtain the 
# following:
#   
#   3^2 – 2×2^2 = 1
#   2^2 – 3×1^2 = 1
#   9^2 – 5×4^2 = 1
#   5^2 – 6×2^2 = 1
#   8^2 – 7×3^2 = 1
# 
# Hence, by considering minimal solutions in x for D ≤ 7, the largest x is 
# obtained when D=5.
# 
# Find the value of D ≤ 1000 in minimal solutions of x for which the largest 
# value of x is obtained.

# Brute force method
diophantine <- data.frame()
for (D in 2:100) {
  
  # Skip squares
  if (sqrt(D) == floor(sqrt(D))) next
  
  # Find the minimal solution of x
  no_int_soln <- TRUE
  x <- 1
  while (no_int_soln) {
    x <- x + 1
    
    y <- sqrt(((x^2) - 1) / D) 
    
    no_int_soln <- y != floor(y)
  }
  
  # Save information
  diophantine <- diophantine %>% 
    bind_rows(data.frame(D, x, y))
  
}

# This works for the example, but is too slow to solve the actual problem
diophantine %>% 
  filter(x == max(x)) %>% 
  pull(D)


# Problem 67 - Maximum path sum II ----------------------------------------

# By starting at the top of the triangle below and moving to adjacent numbers on 
# the row below, the maximum total from top to bottom is 23.
# 
# 3
# 7 4
# 2 4 6
# 8 5 9 3
# 
# That is, 3 + 7 + 4 + 9 = 23.
# 
# Find the maximum total from top to bottom in triangle.txt (right click and 
# 'Save Link/Target As...'), a 15K text file containing a triangle with 
# one-hundred rows.
# 
# NOTE: This is a much more difficult version of Problem 18. It is not possible 
# to try every route to solve this problem, as there are 299 altogether! If you 
# could check one trillion (1012) routes every second it would take over twenty 
# billion years to check them all. There is an efficient algorithm to solve it. 
# ;o)

tri <- read.csv('~/git/project_euler_rkuss/euler_data/p067_triangle.txt',
                header = FALSE) %>% 
  separate(V1, as.character(1:100), sep = " ") %>% 
  mutate_all(as.numeric) %>% 
  replace(is.na(.), 0) %>% 
  as.matrix()

# Set up data frame with decision variables and their values
tri_df <- data.frame(tri) %>% 
  tibble::rownames_to_column("row") %>% 
  gather(col, value, starts_with("X")) %>% 
  mutate(col = str_remove(col, "X"),
         d_var = paste0(row, "-", col),
         row = as.numeric(row),
         col = as.numeric(col)) %>% 
  arrange(d_var) %>% 
  filter(row >= col)

# Create objective function coefficients
obj_coeff <- tri_df %>% 
  pull(value)

# Constraint 1 - sum of all rows is exactly 1
constr1_df <- tri_df %>% 
  mutate(constr_id = as.character(row),
         constr_val = 1,
         dir = "=",
         rhs = 1) %>% 
  select(d_var, dir, rhs, constr_id, constr_val) %>% 
  spread(d_var, constr_val) %>% 
  replace(is.na(.), 0)

# Constraint 2 - can only pick adjacent cells
constr2_df <- tri_df %>% 
  filter(row > 1) %>% 
  rename(constr_id = d_var) %>% 
  mutate(cell_constr = paste0(row, "-", col),
         cell_above_right = paste0(row - 1, "-", col),
         cell_above_left = paste0(row - 1, "-", col - 1)) %>% 
  gather(cell, d_var, starts_with("cell")) %>% 
  filter(d_var %in% tri_df$d_var) %>% 
  mutate(constr_val = if_else(cell == "cell_constr", 1, -1),
         dir = "<=",
         rhs = 0) %>% 
  select(d_var, dir, rhs, constr_id, constr_val) %>% 
  spread(d_var, constr_val) %>% 
  replace(is.na(.), 0)

# Combine constraint data frames
constr_df <- bind_rows(constr1_df,
                       constr2_df)

# Create constraint matrix, direction, and rhs
constr_mat <- constr_df %>% 
  select(all_of(tri_df$d_var)) %>% 
  as.matrix()

constr_dir <- constr_df %>% 
  pull(dir)

constr_rhs <- constr_df %>% 
  pull(rhs)

# Solve the linear program
soln <- lp(direction = "max",
           objective.in = obj_coeff,
           const.mat = constr_mat,
           const.dir = constr_dir,
           const.rhs = constr_rhs,
           all.bin = T)

soln$objval



# Problem 79 - Passcode derivation ----------------------------------------

# A common security method used for online banking is to ask the user for three 
# random characters from a passcode. For example, if the passcode was 531278, 
# they may ask for the 2nd, 3rd, and 5th characters; the expected reply would 
# be: 317.
# 
# The text file, keylog.txt, contains fifty successful login attempts.
# 
# Given that the three characters are always asked for in order, analyse the 
# file so as to determine the shortest possible secret passcode of unknown 
# length.

keylog <- read.csv("~/git/project_euler_rkuss/euler_data/p079_keylog.txt",
                   header = F) %>% 
  rename(code = V1) %>% 
  distinct()

keylog_ordered_pairs <- keylog %>% 
  mutate(op1 = str_sub(code, 1, 2),
         op2 = str_sub(code, 2, 3),
         op3 = paste0(str_sub(code, 1, 1), str_sub(code, 3, 3))) %>% 
  gather(key, op, starts_with("op")) %>% 
  distinct(op) %>% 
  arrange(op)

# Did this one by hand based on all the two-digit ordered pairs that were
# required

# 73162890 - CORRECT!

# Problem 100 - Arranged probability --------------------------------------

# If a box contains twenty-one coloured discs, composed of fifteen blue discs 
# and six red discs, and two discs were taken at random, it can be seen that the 
# probability of taking two blue discs, P(BB) = (15/21)×(14/20) = 1/2.
# 
# The next such arrangement, for which there is exactly 50% chance of taking two 
# blue discs at random, is a box containing eighty-five blue discs and 
# thirty-five red discs.
# 
# By finding the first arrangement to contain over 10^12 = 1,000,000,000,000 
# discs in total, determine the number of blue discs that the box would contain.


n_blue <- 85
n_red <- 35
n_total <- n_blue + n_red

p_bb <- (n_blue / n_total) * ((n_blue - 1) / (n_total - 1))



