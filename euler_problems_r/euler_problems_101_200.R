# Project Euler
# projecteuler.net
# Becca Kuss

source('~/git/project_euler_rkuss/euler_problems_r/euler_functions.R')


# Problem 101 - Optimum polynomial ----------------------------------------

# If we are presented with the first k terms of a sequence it is impossible to 
# say with certainty the value of the next term, as there are infinitely many 
# polynomial functions that can model the sequence.
# 
# As an example, let us consider the sequence of cube numbers. This is defined 
# by the generating function,
# un = n3: 1, 8, 27, 64, 125, 216, ...
# 
# Suppose we were only given the first two terms of this sequence. Working on 
# the principle that "simple is best" we should assume a linear relationship and 
# predict the next term to be 15 (common difference 7). Even if we were 
# presented with the first three terms, by the same principle of simplicity, a 
# quadratic relationship should be assumed.
# 
# We shall define OP(k, n) to be the nth term of the optimum polynomial 
# generating function for the first k terms of a sequence. It should be clear 
# that OP(k, n) will accurately generate the terms of the sequence for n ≤ k, 
# and potentially the first incorrect term (FIT) will be OP(k, k+1); in which 
# case we shall call it a bad OP (BOP).
# 
# As a basis, if we were only given the first term of sequence, it would be most 
# sensible to assume constancy; that is, for n ≥ 2, OP(1, n) = u1.
# 
# Hence we obtain the following OPs for the cubic sequence:
#   
# OP(1, n) = 1	            1, 1, 1, 1, ...
# OP(2, n) = 7n−6	          1, 8, 15, ...
# OP(3, n) = 6n2−11n+6     	1, 8, 27, 58, ...
# OP(4, n) = n3	            1, 8, 27, 64, 125, ...
# Clearly no BOPs exist for k ≥ 4.
# 
# By considering the sum of FITs generated by the BOPs (indicated in red above), 
# we obtain 1 + 15 + 58 = 74.
# 
# Consider the following tenth degree polynomial generating function:
#   
#   un = 1 − n + n2 − n3 + n4 − n5 + n6 − n7 + n8 − n9 + n10
# 
# Find the sum of FITs for the BOPs.

poly_degree <- 10

seq_df <- data.frame(n = 1:100) %>% 
  #mutate(un = n^3) 
  mutate(un = 1 - n + n^2 - n^3 + n^4 - n^5 + n^6 - n^7 + n^8 - n^9 + n^10)

for (k in 1:(poly_degree + 1)) {
  
  if (k == 1) {
    
    # In the simple case, assume a constant sequence
    seq_df <- seq_df %>% 
      mutate(op1n = max(un * (n == 1)))
  } else {
    
    # Get first k terms for fitting model
    seq_fit <- seq_df %>% 
      filter(n <= k)
    
    # Fit the model
    model <- lm(un ~ poly(n, k-1),
                data = seq_fit)
    
    # Predict OP(k,n)
    predictions <- predict(model,
                           newdata = select(seq_df, n))
    
    # Save OP(k,n)
    seq_df <- seq_df %>% 
      mutate(UQ(paste0("op", k, "n")) := predictions)
  }
}

# Check that there are no BOPs for k > 10
stopifnot(
  seq_df %>% 
    mutate(check_op = get(paste0('op', poly_degree + 1, 'n')) - un,
           check_op_pct = check_op / un) %>% 
    filter(abs(check_op_pct) > 1e-3) %>% 
    nrow() == 0
)

# Find the FITs
seq_df %>% 
  gather("k", "opn", starts_with("op")) %>% 
  mutate(k = str_remove(k, "op"),
         k = str_remove(k, "n"),
         k = as.numeric(k)) %>% 
  # Assume the FIT occurs when n = k + 1, and only when k <= poly_degree
  filter(n == k + 1,
         k <= poly_degree) %>% 
  # Get the sum of the FITs
  summarise(sum_fits = sum(opn)) %>% 
  pull(sum_fits)

# 37076114526 - CORRECT!


# Problem 102 - Triangle containment --------------------------------------

# Three distinct points are plotted at random on a Cartesian plane, for which 
# -1000 ≤ x, y ≤ 1000, such that a triangle is formed.
# 
# Consider the following two triangles:
#   
#   A(-340,495), B(-153,-910), C(835,-947)
# 
#   X(-175,41), Y(-421,-714), Z(574,-645)
# 
# It can be verified that triangle ABC contains the origin, whereas triangle 
# XYZ does not.
# 
# Using triangles.txt (right click and 'Save Link/Target As...'), a 27K text 
# file containing the co-ordinates of one thousand "random" triangles, find the 
# number of triangles for which the interior contains the origin.
# 
# NOTE: The first two examples in the file represent the triangles in the 
# example given above.

# Read in names data
triangles <- read.csv("~/git/project_euler_rkuss/euler_data/p102_triangles.txt",
                      header = F) %>% 
  tibble::rownames_to_column("triangle") %>% 
  rename(x_a = V1, y_a = V2,
         x_b = V3, y_b = V4,
         x_c = V5, y_c = V6) %>% 
  gather(key, coordinate, -triangle) %>% 
  separate(key, into = c("x_or_y", "point"), sep = "_")

# Plot the two triangles from the example
triangles %>% 
  filter(triangle %in% 1:2) %>% 
  mutate(triangle = paste("Triangle", triangle)) %>% 
  spread(x_or_y, coordinate) %>% 
  ggplot() +
  aes(x, y, fill = triangle) +
  geom_polygon(alpha = 0.75) +
  geom_hline(yintercept = 0, linetype = 'dashed') +
  geom_vline(xintercept = 0, linetype = 'dashed') +
  xlab("") +
  ylab("") +
  theme_bw() +
  theme(legend.title = element_blank(),
        legend.position = 'bottom')

# Loop through all the triangles to test if they contain origin
triangle_results <- NULL
for (t in unique(triangles$triangle)) {
  
  triangle_t <- triangles %>% 
    filter(triangle == t)
  
  # Get all the coordinates
  ax <- triangle_t %>% filter(x_or_y == "x", point == "a") %>% pull(coordinate)
  ay <- triangle_t %>% filter(x_or_y == "y", point == "a") %>% pull(coordinate)
  bx <- triangle_t %>% filter(x_or_y == "x", point == "b") %>% pull(coordinate)
  by <- triangle_t %>% filter(x_or_y == "y", point == "b") %>% pull(coordinate)
  cx <- triangle_t %>% filter(x_or_y == "x", point == "c") %>% pull(coordinate)
  cy <- triangle_t %>% filter(x_or_y == "y", point == "c") %>% pull(coordinate)
  
  # Figure out which side of the half-place the origin is on
  d1 <- (0 - bx) * (ay - by) - (ax - bx) * (0 - by)
  d2 <- (0 - cx) * (by - cy) - (bx - cx) * (0 - cy)
  d3 <- (0 - ax) * (cy - ay) - (cx - ax) * (0 - ay)
  
  has_neg <- (d1 < 0) | (d2 < 0) | (d3 < 0)
  has_pos <- (d1 > 0) | (d2 > 0) | (d3 > 0)
  
  triangle_results <- data.frame(triangle = t,
                                 contains_origin = !(has_neg & has_pos)) %>% 
    bind_rows(triangle_results)
                                
}

sum(triangle_results$contains_origin)

# Problem 112 - Bouncy numbers --------------------------------------------

# Working from left-to-right if no digit is exceeded by the digit to its left it 
# is called an increasing number; for example, 134468.
# 
# Similarly if no digit is exceeded by the digit to its right it is called a 
# decreasing number; for example, 66420.
# 
# We shall call a positive integer that is neither increasing nor decreasing a 
# "bouncy" number; for example, 155349.
# 
# Clearly there cannot be any bouncy numbers below one-hundred, but just over 
# half of the numbers below one-thousand (525) are bouncy. In fact, the least 
# number for which the proportion of bouncy numbers first reaches 50% is 538.
# 
# Surprisingly, bouncy numbers become more and more common and by the time we 
# reach 21780 the proportion of bouncy numbers is equal to 90%.
# 
# Find the least number for which the proportion of bouncy numbers is exactly 
# 99%.

exact_prop <- 0.90

bouncy_nums <- c()
i <- 0
prop_is_exact <- FALSE
while (!prop_is_exact & i < 500000) {
  
  # Increment i
  i <- i + 1
  
  # Check if i is bouncy
  i_splt <- as.numeric(str_split(as.character(i), pattern = "")[[1]])
  is_increasing <- all(i_splt >= lag(i_splt), na.rm = T)
  is_decreasing <- all(i_splt >= lead(i_splt), na.rm = T)
  is_bouncy <- !any(c(is_increasing, is_decreasing))
  
  # Append it if it's bouncy
  if (is_bouncy) {
    bouncy_nums <- c(bouncy_nums, i)
  }
  
  # Check the proportion of bouncy numbers
  bouncy_prop <- length(bouncy_nums) / i
  prop_is_exact <- bouncy_prop == exact_prop
  
  #message(paste0("i = ", i, ", proportion bouncy = ", bouncy_prop))
  
}

i


# Problem 116 - Red, green or blue tiles ----------------------------------

# A row of five grey square tiles is to have a number of its tiles replaced with 
# coloured oblong tiles chosen from red (length two), green (length three), or 
# blue (length four).
# 
# If red tiles are chosen there are exactly seven ways this can be done.
# 
# If green tiles are chosen there are three ways.
# 
# And if blue tiles are chosen there are two ways.
# 
# Assuming that colours cannot be mixed there are 7 + 3 + 2 = 12 ways of 
# replacing the grey tiles in a row measuring five units in length.
# 
# How many different ways can the grey tiles in a row measuring fifty units in 
# length be replaced if colours cannot be mixed and at least one coloured tile 
# must be used?
#   
# NOTE: This is related to Problem 117.


# Problem 120 - Square remainders -----------------------------------------


# Let r be the remainder when (a−1)^n + (a+1)^n is divided by a^2.
# 
# For example, if a = 7 and n = 3, then r = 42: 63 + 83 = 728 ≡ 42 mod 49. And 
# as n varies, so too will r, but for a = 7 it turns out that rmax = 42.
# 
# For 3 ≤ a ≤ 1000, find ∑ rmax.


a <- 3:1000
n <- 0:10

sq_rem <- data.frame(a) %>% 
  merge(data.frame(n)) %>% 
  mutate(q = (a-1)^n + (a+1)^n,
         a2 = a^2,
         rem = q %% a2)

sq_rem %>% 
  group_by(a) %>% 
  summarise(rmax = max(rem)) %>% 
  ungroup() %>% 
  pull(rmax) %>% 
  sum()


# Problem 124 - Ordered radicals ------------------------------------------

# The radical of n, rad(n), is the product of the distinct prime factors of n. 
# For example, 504 = 23 × 32 × 7, so rad(504) = 2 × 3 × 7 = 42.
# 
# If we calculate rad(n) for 1 ≤ n ≤ 10, then sort them on rad(n), and sorting 
# on n if the radical values are equal, we get:
#   
# Unsorted       Sorted
# n rad(n)       n rad(n) k
# 1     1        1     1  1
# 2     2        2     2  2
# 3     3        4     2  3
# 4     2        8     2  4
# 5     5        3     3  5
# 6     6        9     3  6 
# 7     7        5     5  7
# 8     2        6     6  8
# 9     3        7     7  9
# 10   10       10    10 10

# Let E(k) be the kth element in the sorted n column; for example, E(4) = 8 and 
# E(6) = 9.
# 
# If rad(n) is sorted for 1 ≤ n ≤ 100000, find E(10000).

radicals <- c()
for (n in 2:100000) {
  
  message(n)
  
  # Start with prime factorization of every number up to 10 or 20
  prime_fact <- c()
  n_orig <- n
  
  # 1) While n is divisible by 2, print 2 and divide n by 2.
  while (n %% 2 == 0) {
    prime_fact <- c(prime_fact, 2)
    n <- n / 2
  }
  
  # 2) After step 1, n must be odd. Now start a loop from i = 3 to square root 
  # of n. While i divides n, print i and divide n by i. After i fails to divide 
  # n, increment i by 2 and continue.
  if (n > 2) {
    for (i in seq(from = 3, to = max(sqrt(n),3), by = 2)) {
      while (n %% i == 0) {
        prime_fact <- c(prime_fact, i)
        n <- n / i
      }
    }
  }
  
  # 3) If n is a prime number and is greater than 2, then n will not become 1 by 
  # above two steps. So print n if it is greater than 2.
  if (n > 2) prime_fact <- c(prime_fact, n)
  
  rad_n <- data.frame(n = n_orig,
                      radn = prod(unique(prime_fact)))
  
  radicals <- bind_rows(radicals,
                        rad_n)
  
}

# Sort the list and find the kth element
radicals %>% 
  arrange(radn, n) %>% 
  mutate(k = 1:nrow(radicals) + 1) %>% 
  filter(k == 10000) %>% 
  pull(n)

# 21417 - CORRECT!

# Problem 145 - How many reversible numbers are there below one-bi --------

# Some positive integers n have the property that the sum [ n + reverse(n) ] 
# consists entirely of odd (decimal) digits. For instance, 36 + 63 = 99 and 
# 409 + 904 = 1313. We will call such numbers reversible; so 36, 63, 409, and 
# 904 are reversible. Leading zeroes are not allowed in either n or reverse(n).
# 
# There are 120 reversible numbers below one-thousand.
# 
# How many reversible numbers are there below one-billion (109)?

rev_nums <- data.frame(n = 1:999) %>% 
  # Remove numbers divisible by 10 because reverse(n) would have a leading 0,
  # and remove numbers less than 10, which would always be even when added to
  # itself
  filter(n %% 10 != 0,
         n >= 10) %>% 
  # If both first and last digits are odd or even, you'll end up with an even i
  # n the reversed sum, so remove those
  mutate(n_scale = case_when(n < 10 ~ 1,
                             n < 100 ~ 10,
                             n < 1000 ~ 100,
                             n < 10000 ~ 1000),
         first_digit = floor(n / n_scale),
         last_digit = n - (first_digit * n_scale),
         last_digit = if_else(last_digit > 10, 
                              last_digit - (floor(last_digit / n_scale * 10) * n_scale / 10), 
                              last_digit),
         middle_digit = (n - (first_digit * n_scale) - last_digit) / (n_scale / 10),
         is_odd = n %% 2 == 1,
         is_first_digit_odd = first_digit %% 2 == 1) %>% 
  filter(!(is_odd == is_first_digit_odd)) %>% 
  # Now find reverse(n)
  mutate(rev_n = if_else(n_scale <= 10,
                         (last_digit * n_scale) + first_digit,
                         (last_digit * n_scale) + (middle_digit * n_scale / 10) + first_digit),
         sum = n + rev_n) %>% 
  # Filter out any even sums - shouldn't be any based on pre-filters
  filter(sum %% 2 != 0,
         floor(sum / 10) %% 2 != 0,
         floor(sum / 100) %% 2 != 0 | sum < 100,
         floor(sum / 1000) %% 2 != 0 | sum < 1000)

nrow(rev_nums)
# Works for n < 1000 but won't generalize to larger scales - need to think 
# about how to functionalize and scale this

# Problem 158 - Exploring strings for which only one character com --------

# Taking three different letters from the 26 letters of the alphabet, character 
# strings of length three can be formed.
# Examples are 'abc', 'hat' and 'zyx'.
# When we study these three examples we see that for 'abc' two characters come 
# lexicographically after its neighbour to the left.
# For 'hat' there is exactly one character that comes lexicographically after 
# its neighbour to the left. For 'zyx' there are zero characters that come 
# lexicographically after its neighbour to the left.
# In all there are 10400 strings of length 3 for which exactly one character 
# comes lexicographically after its neighbour to the left.
# 
# We now consider strings of n ≤ 26 different characters from the alphabet.
# For every n, p(n) is the number of strings of length n for which exactly one 
# character comes lexicographically after its neighbour to the left.
# 
# What is the maximum value of p(n)?

pn_df <- data.frame()
for (n in 2:4) {
  
  # Start with a data frame of all combinations
  pn <- merge_n_times(1:26, # use numbers in place of letters
                      n = n, 
                      col = "letter") %>% 
    tibble::rownames_to_column("combo") %>% 
    gather(position, letter, starts_with("letter")) %>% 
    mutate(position = as.numeric(str_remove(position, "letter"))) %>% 
    # Get the neighbor to the left and check if it's after
    group_by(combo) %>% 
    arrange(position) %>% 
    mutate(letter_left = lag(letter),
           comes_after = if_else(is.na(letter_left), FALSE,
                                 letter > letter_left)) %>% 
    summarise(n_comes_after = sum(comes_after)) %>% 
    ungroup() %>% 
    # Count all cases where exactly one letter comes after it's left-neighbor
    filter(n_comes_after == 1) %>% 
    nrow()
  
  pn_df <- bind_rows(pn_df,
                     data.frame(n = n, pn = pn))
}

# Getting 11700 for n = 3, which isn't even right, plus this algorithm is way
# too slow




# Problem 191 - Prize Strings ---------------------------------------------


# A particular school offers cash rewards to children with good attendance and 
# punctuality. If they are absent for three consecutive days or late on more 
# than one occasion then they forfeit their prize.
# 
# During an n-day period a trinary string is formed for each child consisting of 
# L's (late), O's (on time), and A's (absent).
# 
# Although there are eighty-one trinary strings for a 4-day period that can be 
# formed, exactly forty-three strings would lead to a prize:
# 
# OOOO OOOA OOOL OOAO OOAA OOAL OOLO OOLA OAOO OAOA OAOL OAAO OAAL OALO OALA 
# OLOO OLOA OLAO OLAA AOOO AOOA AOOL AOAO AOAA AOAL AOLO AOLA AAOO AAOA AAOL
# AALO AALA ALOO ALOA ALAO ALAA LOOO LOOA LOAO LOAA LAOO LAOA LAAO
# 
# How many "prize" strings exist over a 30-day period?

n_days <- 4

# Start with the total number of strings
num_strings <- 3^n_days

# Find the number of strings with more than one L





