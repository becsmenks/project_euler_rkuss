# Project Euler
# projecteuler.net
# Becca Kuss

source('~/git/project_euler_rkuss/euler_functions.R')


# Problem 101 - Optimum polynomial ----------------------------------------

# If we are presented with the first k terms of a sequence it is impossible to 
# say with certainty the value of the next term, as there are infinitely many 
# polynomial functions that can model the sequence.
# 
# As an example, let us consider the sequence of cube numbers. This is defined 
# by the generating function,
# un = n3: 1, 8, 27, 64, 125, 216, ...
# 
# Suppose we were only given the first two terms of this sequence. Working on 
# the principle that "simple is best" we should assume a linear relationship and 
# predict the next term to be 15 (common difference 7). Even if we were 
# presented with the first three terms, by the same principle of simplicity, a 
# quadratic relationship should be assumed.
# 
# We shall define OP(k, n) to be the nth term of the optimum polynomial 
# generating function for the first k terms of a sequence. It should be clear 
# that OP(k, n) will accurately generate the terms of the sequence for n ≤ k, 
# and potentially the first incorrect term (FIT) will be OP(k, k+1); in which 
# case we shall call it a bad OP (BOP).
# 
# As a basis, if we were only given the first term of sequence, it would be most 
# sensible to assume constancy; that is, for n ≥ 2, OP(1, n) = u1.
# 
# Hence we obtain the following OPs for the cubic sequence:
#   
# OP(1, n) = 1	            1, 1, 1, 1, ...
# OP(2, n) = 7n−6	          1, 8, 15, ...
# OP(3, n) = 6n2−11n+6     	1, 8, 27, 58, ...
# OP(4, n) = n3	            1, 8, 27, 64, 125, ...
# Clearly no BOPs exist for k ≥ 4.
# 
# By considering the sum of FITs generated by the BOPs (indicated in red above), 
# we obtain 1 + 15 + 58 = 74.
# 
# Consider the following tenth degree polynomial generating function:
#   
#   un = 1 − n + n2 − n3 + n4 − n5 + n6 − n7 + n8 − n9 + n10
# 
# Find the sum of FITs for the BOPs.

poly_degree <- 10

seq_df <- data.frame(n = 1:100) %>% 
  #mutate(un = n^3) 
  mutate(un = 1 - n + n^2 - n^3 + n^4 - n^5 + n^6 - n^7 + n^8 - n^9 + n^10)

for (k in 1:(poly_degree + 1)) {
  
  if (k == 1) {
    
    # In the simple case, assume a constant sequence
    seq_df <- seq_df %>% 
      mutate(op1n = max(un * (n == 1)))
  } else {
    
    # Get first k terms for fitting model
    seq_fit <- seq_df %>% 
      filter(n <= k)
    
    # Fit the model
    model <- lm(un ~ poly(n, k-1),
                data = seq_fit)
    
    # Predict OP(k,n)
    predictions <- predict(model,
                           newdata = select(seq_df, n))
    
    # Save OP(k,n)
    seq_df <- seq_df %>% 
      mutate(UQ(paste0("op", k, "n")) := predictions)
  }
}

# Check that there are no BOPs for k > 10
stopifnot(
  seq_df %>% 
    mutate(check_op = get(paste0('op', poly_degree + 1, 'n')) - un,
           check_op_pct = check_op / un) %>% 
    filter(abs(check_op_pct) > 1e-3) %>% 
    nrow() == 0
)

# Find the FITs
seq_df %>% 
  gather("k", "opn", starts_with("op")) %>% 
  mutate(k = str_remove(k, "op"),
         k = str_remove(k, "n"),
         k = as.numeric(k)) %>% 
  # Assume the FIT occurs when n = k + 1, and only when k <= poly_degree
  filter(n == k + 1,
         k <= poly_degree) %>% 
  # Get the sum of the FITs
  summarise(sum_fits = sum(opn)) %>% 
  pull(sum_fits)

# 37076114526 - CORRECT!


# Problem 102 - Triangle containment --------------------------------------

# Three distinct points are plotted at random on a Cartesian plane, for which 
# -1000 ≤ x, y ≤ 1000, such that a triangle is formed.
# 
# Consider the following two triangles:
#   
#   A(-340,495), B(-153,-910), C(835,-947)
# 
#   X(-175,41), Y(-421,-714), Z(574,-645)
# 
# It can be verified that triangle ABC contains the origin, whereas triangle 
# XYZ does not.
# 
# Using triangles.txt (right click and 'Save Link/Target As...'), a 27K text 
# file containing the co-ordinates of one thousand "random" triangles, find the 
# number of triangles for which the interior contains the origin.
# 
# NOTE: The first two examples in the file represent the triangles in the 
# example given above.

# Read in names data
triangles <- read.csv("~/git/project_euler_rkuss/euler_data/p102_triangles.txt",
                      header = F) %>% 
  tibble::rownames_to_column("triangle") %>% 
  rename(x_a = V1, y_a = V2,
         x_b = V3, y_b = V4,
         x_c = V5, y_c = V6) %>% 
  gather(key, coordinate, -triangle) %>% 
  separate(key, into = c("x_or_y", "point"), sep = "_")

# Check if any coordinates lie on the origin or axes
triangles %>% 
  group_by(triangle, point) %>% 
  summarise(is_on_axis = any(coordinate == 0),
            is_on_origin = all(coordinate == 0)) %>% 
  ungroup() %>% 
  View()



# Problem 112 - Bouncy numbers --------------------------------------------

# Working from left-to-right if no digit is exceeded by the digit to its left it 
# is called an increasing number; for example, 134468.
# 
# Similarly if no digit is exceeded by the digit to its right it is called a 
# decreasing number; for example, 66420.
# 
# We shall call a positive integer that is neither increasing nor decreasing a 
# "bouncy" number; for example, 155349.
# 
# Clearly there cannot be any bouncy numbers below one-hundred, but just over 
# half of the numbers below one-thousand (525) are bouncy. In fact, the least 
# number for which the proportion of bouncy numbers first reaches 50% is 538.
# 
# Surprisingly, bouncy numbers become more and more common and by the time we 
# reach 21780 the proportion of bouncy numbers is equal to 90%.
# 
# Find the least number for which the proportion of bouncy numbers is exactly 
# 99%.

exact_prop <- 0.99

bouncy_nums <- c()
i <- 0
prop_is_exact <- FALSE
while (!prop_is_exact & i < 500000) {
  
  # Increment i
  i <- i + 1
  
  # Check if i is bouncy
  i_splt <- as.numeric(str_split(as.character(i), pattern = "")[[1]])
  is_increasing <- all(i_splt >= lag(i_splt), na.rm = T)
  is_decreasing <- all(i_splt >= lead(i_splt), na.rm = T)
  is_bouncy <- !any(c(is_increasing, is_decreasing))
  
  # Append it if it's bouncy
  if (is_bouncy) {
    bouncy_nums <- c(bouncy_nums, i)
  }
  
  # Check the proportion of bouncy numbers
  # Use i + 1 because we've checked all the numbers up to and including i
  bouncy_prop <- length(bouncy_nums) / i
  prop_is_exact <- bouncy_prop == exact_prop
  
}

i


# Problem 120 - Square remainders -----------------------------------------


# Let r be the remainder when (a−1)^n + (a+1)^n is divided by a^2.
# 
# For example, if a = 7 and n = 3, then r = 42: 63 + 83 = 728 ≡ 42 mod 49. And 
# as n varies, so too will r, but for a = 7 it turns out that rmax = 42.
# 
# For 3 ≤ a ≤ 1000, find ∑ rmax.


a <- 3:1000
n <- 0:10

sq_rem <- data.frame(a) %>% 
  merge(data.frame(n)) %>% 
  mutate(q = (a-1)^n + (a+1)^n,
         a2 = a^2,
         rem = q %% a2)

sq_rem %>% 
  group_by(a) %>% 
  summarise(rmax = max(rem)) %>% 
  ungroup() %>% 
  pull(rmax) %>% 
  sum()




# Problem 145 - How many reversible numbers are there below one-bi --------

# Some positive integers n have the property that the sum [ n + reverse(n) ] 
# consists entirely of odd (decimal) digits. For instance, 36 + 63 = 99 and 
# 409 + 904 = 1313. We will call such numbers reversible; so 36, 63, 409, and 
# 904 are reversible. Leading zeroes are not allowed in either n or reverse(n).
# 
# There are 120 reversible numbers below one-thousand.
# 
# How many reversible numbers are there below one-billion (109)?

rev_nums <- data.frame(n = 1:999) %>% 
  # Remove numbers divisible by 10 because reverse(n) would have a leading 0,
  # and remove numbers less than 10, which would always be even when added to
  # itself
  filter(n %% 10 != 0,
         n >= 10) %>% 
  # If both first and last digits are odd or even, you'll end up with an even i
  # n the reversed sum, so remove those
  mutate(n_scale = case_when(n < 10 ~ 1,
                             n < 100 ~ 10,
                             n < 1000 ~ 100,
                             n < 10000 ~ 1000),
         first_digit = floor(n / n_scale),
         last_digit = n - (first_digit * n_scale),
         last_digit = if_else(last_digit > 10, 
                              last_digit - (floor(last_digit / n_scale * 10) * n_scale / 10), 
                              last_digit),
         middle_digit = (n - (first_digit * n_scale) - last_digit) / (n_scale / 10),
         is_odd = n %% 2 == 1,
         is_first_digit_odd = first_digit %% 2 == 1) %>% 
  filter(!(is_odd == is_first_digit_odd)) %>% 
  # Now find reverse(n)
  mutate(rev_n = if_else(n_scale <= 10,
                         (last_digit * n_scale) + first_digit,
                         (last_digit * n_scale) + (middle_digit * n_scale / 10) + first_digit),
         sum = n + rev_n) %>% 
  # Filter out any even sums - shouldn't be any based on pre-filters
  filter(sum %% 2 != 0,
         floor(sum / 10) %% 2 != 0,
         floor(sum / 100) %% 2 != 0 | sum < 100,
         floor(sum / 1000) %% 2 != 0 | sum < 1000)

nrow(rev_nums)
# Works for n < 1000 but won't generalize to larger scales - need to think 
# about how to functionalize and scale this

# Problem 158 - Exploring strings for which only one character com --------

# Taking three different letters from the 26 letters of the alphabet, character 
# strings of length three can be formed.
# Examples are 'abc', 'hat' and 'zyx'.
# When we study these three examples we see that for 'abc' two characters come 
# lexicographically after its neighbour to the left.
# For 'hat' there is exactly one character that comes lexicographically after 
# its neighbour to the left. For 'zyx' there are zero characters that come 
# lexicographically after its neighbour to the left.
# In all there are 10400 strings of length 3 for which exactly one character 
# comes lexicographically after its neighbour to the left.
# 
# We now consider strings of n ≤ 26 different characters from the alphabet.
# For every n, p(n) is the number of strings of length n for which exactly one 
# character comes lexicographically after its neighbour to the left.
# 
# What is the maximum value of p(n)?

pn_df <- data.frame()
for (n in 2:4) {
  
  # Start with a data frame of all combinations
  pn <- merge_n_times(1:26, # use numbers in place of letters
                      n = n, 
                      col = "letter") %>% 
    tibble::rownames_to_column("combo") %>% 
    gather(position, letter, starts_with("letter")) %>% 
    mutate(position = as.numeric(str_remove(position, "letter"))) %>% 
    # Get the neighbor to the left and check if it's after
    group_by(combo) %>% 
    arrange(position) %>% 
    mutate(letter_left = lag(letter),
           comes_after = if_else(is.na(letter_left), FALSE,
                                 letter > letter_left)) %>% 
    summarise(n_comes_after = sum(comes_after)) %>% 
    ungroup() %>% 
    # Count all cases where exactly one letter comes after it's left-neighbor
    filter(n_comes_after == 1) %>% 
    nrow()
  
  pn_df <- bind_rows(pn_df,
                     data.frame(n = n, pn = pn))
}

# Getting 11700 for n = 3, which isn't even right, plus this algorithm is way
# too slow













