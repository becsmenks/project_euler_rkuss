# Project Euler
# projecteuler.net
# Becca Kuss

library(dplyr)
library(tidyr)
library(stringr)
library(lubridate)

source('~/git/project_euler_rkuss/euler_functions.R')


# Problem 101 - Optimum polynomial ----------------------------------------

# If we are presented with the first k terms of a sequence it is impossible to 
# say with certainty the value of the next term, as there are infinitely many 
# polynomial functions that can model the sequence.
# 
# As an example, let us consider the sequence of cube numbers. This is defined 
# by the generating function,
# un = n3: 1, 8, 27, 64, 125, 216, ...
# 
# Suppose we were only given the first two terms of this sequence. Working on 
# the principle that "simple is best" we should assume a linear relationship and 
# predict the next term to be 15 (common difference 7). Even if we were 
# presented with the first three terms, by the same principle of simplicity, a 
# quadratic relationship should be assumed.
# 
# We shall define OP(k, n) to be the nth term of the optimum polynomial 
# generating function for the first k terms of a sequence. It should be clear 
# that OP(k, n) will accurately generate the terms of the sequence for n ≤ k, 
# and potentially the first incorrect term (FIT) will be OP(k, k+1); in which 
# case we shall call it a bad OP (BOP).
# 
# As a basis, if we were only given the first term of sequence, it would be most 
# sensible to assume constancy; that is, for n ≥ 2, OP(1, n) = u1.
# 
# Hence we obtain the following OPs for the cubic sequence:
#   
# OP(1, n) = 1	            1, 1, 1, 1, ...
# OP(2, n) = 7n−6	          1, 8, 15, ...
# OP(3, n) = 6n2−11n+6     	1, 8, 27, 58, ...
# OP(4, n) = n3	            1, 8, 27, 64, 125, ...
# Clearly no BOPs exist for k ≥ 4.
# 
# By considering the sum of FITs generated by the BOPs (indicated in red above), 
# we obtain 1 + 15 + 58 = 74.
# 
# Consider the following tenth degree polynomial generating function:
#   
#   un = 1 − n + n2 − n3 + n4 − n5 + n6 − n7 + n8 − n9 + n10
# 
# Find the sum of FITs for the BOPs.

poly_degree <- 10

seq_df <- data.frame(n = 1:100) %>% 
  #mutate(un = n^3) 
  mutate(un = 1 - n + n^2 - n^3 + n^4 - n^5 + n^6 - n^7 + n^8 - n^9 + n^10)

for (k in 1:(poly_degree + 1)) {
  
  if (k == 1) {
    
    # In the simple case, assume a constant sequence
    seq_df <- seq_df %>% 
      mutate(op1n = max(un * (n == 1)))
  } else {
    
    # Get first k terms for fitting model
    seq_fit <- seq_df %>% 
      filter(n <= k)
    
    # Fit the model
    model <- lm(un ~ poly(n, k-1),
                data = seq_fit)
    
    # Predict OP(k,n)
    predictions <- predict(model,
                           newdata = select(seq_df, n))
    
    # Save OP(k,n)
    seq_df <- seq_df %>% 
      mutate(UQ(paste0("op", k, "n")) := predictions)
  }
}

# Check that there are no BOPs for k > 10
stopifnot(
  seq_df %>% 
    mutate(check_op = get(paste0('op', poly_degree + 1, 'n')) - un,
           check_op_pct = check_op / un) %>% 
    filter(abs(check_op_pct) > 1e-3) %>% 
    nrow() == 0
)

# Find the FITs
seq_df %>% 
  gather("k", "opn", starts_with("op")) %>% 
  mutate(k = str_remove(k, "op"),
         k = str_remove(k, "n"),
         k = as.numeric(k)) %>% 
  # Assume the FIT occurs when n = k + 1, and only when k <= poly_degree
  filter(n == k + 1,
         k <= poly_degree) %>% 
  # Get the sum of the FITs
  summarise(sum_fits = sum(opn)) %>% 
  pull(sum_fits)

# 37076114526 - CORRECT!


# Problem 158 - Exploring strings for which only one character com --------

# Taking three different letters from the 26 letters of the alphabet, character 
# strings of length three can be formed.
# Examples are 'abc', 'hat' and 'zyx'.
# When we study these three examples we see that for 'abc' two characters come 
# lexicographically after its neighbour to the left.
# For 'hat' there is exactly one character that comes lexicographically after 
# its neighbour to the left. For 'zyx' there are zero characters that come 
# lexicographically after its neighbour to the left.
# In all there are 10400 strings of length 3 for which exactly one character 
# comes lexicographically after its neighbour to the left.
# 
# We now consider strings of n ≤ 26 different characters from the alphabet.
# For every n, p(n) is the number of strings of length n for which exactly one 
# character comes lexicographically after its neighbour to the left.
# 
# What is the maximum value of p(n)?

pn_df <- data.frame()
for (n in 2:4) {
  
  # Start with a data frame of all combinations
  pn <- merge_n_times(1:26, # use numbers in place of letters
                      n = n, 
                      col = "letter") %>% 
    tibble::rownames_to_column("combo") %>% 
    gather(position, letter, starts_with("letter")) %>% 
    mutate(position = as.numeric(str_remove(position, "letter"))) %>% 
    # Get the neighbor to the left and check if it's after
    group_by(combo) %>% 
    arrange(position) %>% 
    mutate(letter_left = lag(letter),
           comes_after = if_else(is.na(letter_left), FALSE,
                                 letter > letter_left)) %>% 
    summarise(n_comes_after = sum(comes_after)) %>% 
    ungroup() %>% 
    # Count all cases where exactly one letter comes after it's left-neighbor
    filter(n_comes_after == 1) %>% 
    nrow()
  
  pn_df <- bind_rows(pn_df,
                     data.frame(n = n, pn = pn))
}

# Getting 11700 for n = 3, which isn't even right, plus this algorithm is way
# too slow













