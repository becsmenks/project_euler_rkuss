# Project Euler
# projecteuler.net
# Becca Kuss

library(dplyr)
library(tidyr)
library(stringr)
library(lubridate)

source('~/git/project_euler_rkuss/euler_functions.R')


# Problem 101 - Optimum polynomial ----------------------------------------

# If we are presented with the first k terms of a sequence it is impossible to 
# say with certainty the value of the next term, as there are infinitely many 
# polynomial functions that can model the sequence.
# 
# As an example, let us consider the sequence of cube numbers. This is defined 
# by the generating function,
# un = n3: 1, 8, 27, 64, 125, 216, ...
# 
# Suppose we were only given the first two terms of this sequence. Working on 
# the principle that "simple is best" we should assume a linear relationship and 
# predict the next term to be 15 (common difference 7). Even if we were 
# presented with the first three terms, by the same principle of simplicity, a 
# quadratic relationship should be assumed.
# 
# We shall define OP(k, n) to be the nth term of the optimum polynomial 
# generating function for the first k terms of a sequence. It should be clear 
# that OP(k, n) will accurately generate the terms of the sequence for n ≤ k, 
# and potentially the first incorrect term (FIT) will be OP(k, k+1); in which 
# case we shall call it a bad OP (BOP).
# 
# As a basis, if we were only given the first term of sequence, it would be most 
# sensible to assume constancy; that is, for n ≥ 2, OP(1, n) = u1.
# 
# Hence we obtain the following OPs for the cubic sequence:
#   
# OP(1, n) = 1	            1, 1, 1, 1, ...
# OP(2, n) = 7n−6	          1, 8, 15, ...
# OP(3, n) = 6n2−11n+6     	1, 8, 27, 58, ...
# OP(4, n) = n3	            1, 8, 27, 64, 125, ...
# Clearly no BOPs exist for k ≥ 4.
# 
# By considering the sum of FITs generated by the BOPs (indicated in red above), 
# we obtain 1 + 15 + 58 = 74.
# 
# Consider the following tenth degree polynomial generating function:
#   
#   un = 1 − n + n2 − n3 + n4 − n5 + n6 − n7 + n8 − n9 + n10
# 
# Find the sum of FITs for the BOPs.

poly_degree <- 10

seq_df <- data.frame(n = 1:100) %>% 
  #mutate(un = n^3) 
  mutate(un = 1 - n + n^2 - n^3 + n^4 - n^5 + n^6 - n^7 + n^8 - n^9 + n^10)

for (k in 1:(poly_degree + 1)) {
  
  if (k == 1) {
    
    # In the simple case, assume a constant sequence
    seq_df <- seq_df %>% 
      mutate(op1n = max(un * (n == 1)))
  } else {
    
    # Get first k terms for fitting model
    seq_fit <- seq_df %>% 
      filter(n <= k)
    
    # Fit the model
    model <- lm(un ~ poly(n, k-1),
                data = seq_fit)
    
    # Predict OP(k,n)
    predictions <- predict(model,
                           newdata = select(seq_df, n))
    
    # Save OP(k,n)
    seq_df <- seq_df %>% 
      mutate(UQ(paste0("op", k, "n")) := predictions)
  }
}

# Check that there are no BOPs for k > 10
stopifnot(
  seq_df %>% 
    mutate(check_op = get(paste0('op', poly_degree + 1, 'n')) - un,
           check_op_pct = check_op / un) %>% 
    filter(abs(check_op_pct) > 1e-3) %>% 
    nrow() == 0
)

# Find the FITs
seq_df %>% 
  gather("k", "opn", starts_with("op")) %>% 
  mutate(k = str_remove(k, "op"),
         k = str_remove(k, "n"),
         k = as.numeric(k)) %>% 
  # Assume the FIT occurs when n = k + 1, and only when k <= poly_degree
  filter(n == k + 1,
         k <= poly_degree) %>% 
  # Get the sum of the FITs
  summarise(sum_fits = sum(opn)) %>% 
  pull(sum_fits)

# 37076114526 - CORRECT!
